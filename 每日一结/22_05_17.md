# 22年5月17号日结

## 刷题

java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。在实例方法中出现变量名相同时，可以使用this关键字来调用。

二维数组定义，一维长度必须定义，二维可以后续定义

调用start（）后，**线程会被放到等待队列**，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。
1.start（）方法来启动线程，真正实现了多线程运行。**这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码**；
2.run（）方法当作普通方法的方式调用。程序还是要顺序执行，**要等待run方法体执行完毕**后，才可继续执行下面的代码， 这样就没有达到写线程的目的。

<img src="https://uploadfiles.nowcoder.com/images/20161027/5918115_1477539264126_C8F72CB9ADDE474B30FDD49816380C02" alt="img" style="zoom: 80%;" />

JDK中提供了三个ClassLoader，根据层级从高到低为：

1. Bootstrap ClassLoader，主要加载JVM自身工作需要的类。
2. Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。
3. Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是**ClassLoader.getSystemClassLoader()** 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）

JVM加载类的实现方式，我们称为 **双亲委托模型**：

如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委托给自己的父加载器，每一层的类加载器都是如此，因此所有的类加载请求最终都应该传送到顶层的**Bootstrap ClassLoader**中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。

**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。**

假设有一个开发者自己编写了一个名为***[Java](http://lib.csdn.net/base/java).lang.Object\***的类，想借此欺骗JVM。现在他要使用**自定义ClassLoader**来加载自己编写的***java.lang.Object\***类。然而幸运的是，**双亲委托模型**不会让他成功。因为JVM会优先在**Bootstrap ClassLoader**的路径下找到***java.lang.Object\***类，并载入它

1.静态代码块 2.构造代码块3.构造方法的执行顺序是1>2>3;明白他们是干嘛的就理解了。
1.静态代码块：是在类的加载过程的第三步初始化的时候进行的，主要目的是给类变量赋予初始值。
2.构造代码块：是独立的，必须依附载体才能运行，Java会把构造代码块放到每种构造方法的前面，用于实例化一些共有的实例变量，减少代码量。
3.构造方法：用于实例化变量。
1是类级别的，2、3是实例级别的，自然1要优先23.
在就明白一点：对子类得主动使用会导致对其父类得主动使用，所以尽管实例化的是子类，但也会导致父类的初始化和实例化，且优于子类执行。

Java程序初始化工作可以在许多不同的代码块中来完成，它们的执行顺序如下：

1. **父类**的静态变量、父类的静态代码块、**子类**的静态变量、子类的静态代码块、
2. 父类的**非静态**变量、父类的非静态代码块、**父类的构造函数**、
3. 子类的非静态变量、子类的非静态代码块、子类的构造函数。

run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。<br>而start()的作用是启动相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。

char、byte、short相加时会自动转换为int类型