# 数据结构与算法

 ## 数组

- 一维数组 a[n]：a[i]的存储地址  a+i*len
- 二维数组 a[m] [n]：<br>a[i] [j]的存储地址（按行存储） a+(i*n+j)*len <br>a[i] [j]的存储地址（按列存储） a+(j*m+i)*len

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524125753565.png" alt="image-20220524125753565" width="40%" />

## 线性表

线性表是n个元素的有限序列，记为（a1,a2,a3.....an)

- 存在唯一的一个称作“第一个”的元素
- 存在唯一的一个称作“最后一个”的元素
- 除了表头外，表中的每一个元素均只有唯一的直接前趋
- 除了表尾外，表中的每一个元素均只有唯一的直接后继



<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524125741432.png" alt="image-20220524125741432" width="40%" />

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524125729084.png" alt="image-20220524125729084" width="40%" />

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524125716385.png" alt="image-20220524125716385" width="40%" />

## 队列与栈

- 队列：一种先进先出（FIFO）的线性表
- 栈：先进后出（FILO）的线性表

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524125630048.png" alt="image-20220524125630048" width="40%" />

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524125830222.png" alt="image-20220524125830222" width="40%"/>

## 广义表

广义表是线性表的推广，是由0个或多个单元素或子表所组成的有限序列

与线性表的区别：线性表的元素都是结构上不可分的单元素，而广义表的元素既可以是单元素，也可以是有结构的表。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524125854205.png" alt="image-20220524125854205" width="45%" />

## 树与二叉树

树是n(n>=0)个节点的有限集合，n=0时称为空树。

- 双亲和孩子：节点的子树的根称为该节点的孩子，该节点称为其子节点的双亲。
- 兄弟：具有相同双亲的节点互为兄弟。
- 节点的度：一个节点的子树的个数记为该节点的度。
- 叶子节点：也称为终端节点，指度为0的节点。
- 内部节点：度不为0的节点称为分节点或非终端节点。除根节点之外，分支节点也称为内部节点。
- 节点的层次：根为第一层，根的孩子为第二层，依次类推。
- 树的高度：一棵树的最大层次数记为树的高度（或深度）
- 有序（无序）树：若将树中的节点的各子树看成是从左到右具有次序的，即不能交换，则称该树为有序树。
- 森林：m(m>=0)课互不相交的树的集合。

### 二叉树

二叉树是n(n>=0)个节点的有限集合，或者是空树（n=0），或者是由一个根节点及两颗互不相交的、分别称为左子树和右子树的二叉树所组成。

二叉树与树的区别：二叉树节点的子树要区分左子树和右子树，即使在节点只有一颗子树的情况下要明确指出该子树是左子树还是右子树。<br>二叉树的节点最大度为2，而树中不限制节点的度数。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524130950955.png" alt="image-20220524130950955" width="45%" />

### 树的遍历

- 层次遍历：从树的根节点出发，首先访问第一层的根节点，然后从左到右依次访问第2层上的节点，依次类推，自上而下、自左到右逐层访问树中各层上节点的过程。
- 先序遍历：先遍历根节点，再遍历左节点，最后遍历右节点；
- 中序遍历：先遍历左节点，再遍历根节点，最后遍历右节点；
- 后序遍历：先遍历左节点，再遍历右节点，最后遍历根节点；

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524134306177.png" alt="image-20220524134306177" width="45%" />

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524134318321.png" alt="image-20220524134318321" width="45%" />

### 查找二叉树

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524134401219.png" alt="image-20220524134401219" width="45%" />

### 最优二叉树

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524134421637.png" alt="image-20220524134421637" width="45%" />

## 排序

### 直接插入排序

即当插入第i个记录时，R1，R2，....，Ri-1均已排好序，因此，将第i个记录Ri依次与Ri-1，....，R2，R1进行比较，找到合适的位置插入，简单明了，但速度很慢。

### 希尔排序

先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d<sub>1</sub>个组。所有距离为d1的倍数的记录放在同一个组中，先在各组内进行直接插入排序；然后取第二个增量d<sub>2</sub><d<sub>1</sub>重复上述的分组和排序，直至所取的增量dt=<sub>1</sub>（d<sub>t</sub><d<sub>t-1</sub><o<d<sub>2</sub><d<sub>1</sub>），即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。

### 直接选择排序

过程是首先在所有记录中选出排序码最小的记录，把它与第1个记录交换，然后在其余的记录内选出排序码最小的记录，与第2个记录交换......依次类推，直到所有记录排完为止。

### 快速排序

快速排序采用的分治法，其基本思想是将原问题分解成若干个规模更小但结构与原问题相似的子问题。通过递归地解决这些子问题，然后再将这些子问题的解组合成原问题的解。

- 第一步：在待排序的n个记录中任取一个记录，以该记录的排序码为准，将所有记录都分成两组，第一组都小于该数，第二组都大于该数。
- 第二步：采用相同的方法第左、右两组分别进行排序，直到所有记录都排到相应的位置。

### 堆排序

设有n个元素的序列{K<sub>1</sub>，K<sub>2</sub>，...，K<sub>n</sub>}，当且仅当满足下述关系之一时，称之为堆。

- k<sub>i</sub><=k<sub>2i</sub>，且ki<=k<sub>2i+1</sub>  小顶堆
- k<sub>i</sub>>=k<sub>2i</sub>，且ki>=k<sub>2i+1</sub>  大顶堆

### 冒泡排序

基本思想是，通过相邻的元素之间的比较和交换，将排序码小的元素逐渐从底部移向顶部。

### 归并排序

是将两个或两个以上的有序子表合并成一个新的有序表，若将两个有序表合并成一个有序表，则称为二路合并。合并过程是：比较A[i]和A[j]的排序码大小，若A[i]的排序小于A[j]的排序码，则将第一个有序表中的元素A[i]复制到R[k]中，并令i和k分别加1；如此循环下去，直到其中一个有序表比较和复制完，然后再将另一个有序表的剩余元素赋值到R中。

### 基数排序

基数排序是一种借组多关键字排序思想对单逻辑关键字进行排序的方法。基数排序不是基于关键字比较的排序方法，它适合于元素很多而关键字较少的序列。基数的选择和关键字的分解是根据关键字的类型来决定的。

