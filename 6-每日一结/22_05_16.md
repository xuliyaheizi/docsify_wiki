# 22年5月16号日结

## 刷题

Java中的位运算符：

- 左移n位：相当于乘以2n  右移n位：相当于除以2n
- \>>表示右移，如果该数为正，则高位补0，若为负数，则高位补1；
- \>>>表示无符号右移，也叫逻辑右移，即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0。

object类――众类鼻祖 1.取得对象信息：toString():对象输出时，会默认调用Object类的toString()方法，将对象信息变为字符串返回。 2.对象相等判断方法：equals():两个对象进行比较时，实际上是比较两个对象的地址值（从程序看出两个对象内容完全相等，但是结果是不相等的，这是因为classa与classb的内容分别在不同的内存空间指向了不同的内存地址）。所以要对equals()进行覆写，判断equals()方法里面的Object类对象是否与调用equals()的类是同一个类的实例(用instanceof判断)，如果是，则进行向下转型，然后再调用String类中的equals方法对属性进行比较。 3.对象签名：hashCode():Object类有两种方法来推断对象的标识：equals()和hashCode()。如果根据equals()方法判断两个对象是相等的，那么对这两个对象中的每一个调用hashCode()方法都必然生成相同的整数结果。但是反过来，如果两个hashCode()返回的结果相等，两个对象的equals()方法却不一定相等。在默认情况下equals()方法用来比较两个对象的地址值，而原始的hashCode()方法用来返回其所在对象的物理地址（ps：对于非字符串变量而言，equals和==比较的是地址，对于字符串变量而言equals()比较的是内容==比较地址）

哪些操作会使线程释放锁资源？

1. sleep会使当前线程睡眠指定时间，不释放锁
2. yield会使当前线程重回到可执行状态，等待cpu的调度，不释放锁
3. wait会使当前线程回到线程池中等待，释放锁，当被其他线程使用notify，notifyAll唤醒时进入可执行状态
4. 当前线程调用 某线程.join（）时会使当前线程等待某线程执行完毕再结束，底层调用了wait，释放锁

首先final声明的方法是不能被覆盖的，但是这里并不错误，因为方法是private的，也就是子类没有继承父类的run方法，因此子类的run方法跟父类的run方法无关，并不是覆盖。

[**Java** ](http://lib.csdn.net/base/javase)重载的规则：

1. 必须具有不同的参数列表；
2. 可以有不同的返回类型，只要参数列表不同就可以；
3. 可以有不同的访问修饰符；
4. 可以抛出不同的异常；
5. 方法能够在一个类中或者在一个子类中被重载。

**方法的重写：**

1. 在子类中可以根据需要对从基类中继承来的方法进行重写。
2. 重写的方法和被重写的方法必须具有相同方法名称、参数列表和返回类型。
3. 重写方法不能使用比被重写的方法更严格的访问权限。
4. 重写方法不能抛出新的异常或者比被重写方法声明的检查异常更广的检查异常。但是可以抛出更少，更有限或者不抛出异常。 
5. 父类中被final修饰的方法不能被重写
6. 如果想调用父类被覆盖的方法，用super关键字调用

- f 虽然是 Test 类的私有成员属性，但因为 main 方法就在 Test 类内，因此可以通过 “对象名.属性名” 的方式调用，所以 A 对。
- static 静态成员属性不能使用 this 关键字调用，B 错
- m 和 f 都是普通成员属性，而 “类名.” 方式只能调用 静态成员属性，因此 C 和 D 都错。

方法头指：修饰符+[返回类型](https://www.baidu.com/s?wd=返回类型&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao) +方法名（形参列表）<br>接口的访问权限：public，abstract两同两小一大原则返回值和参数列表相同返回值类型小于等于父类的返回值类型异常小于等于父类抛出异常访问权限大于等于父类

抛InterruptedException的代表方法有：

- java.lang.Object 类的 wait 方法
- java.lang.Thread 类的 sleep 方法
- java.lang.Thread 类的 join 方法