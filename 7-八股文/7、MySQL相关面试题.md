# MySQL相关面试题

## 1、数据库的三范式？

- **第一范式：**列不可再分（无重复的列）。
- **第二范式：**属性完全依赖于主键（消除部分子函数依赖）。
- **第三范式：**表的非主属性不能依赖与其他表的非主属性外键约束（消除传递依赖）。

三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立在第一第二范式上。

## 2、Mysql的数据库引擎？

```mysql
mysql> show engines
```

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207282110504.png" alt="image-20220708101035699" width="80%;" />

`mysql常用引擎包括`：MYISAM、Innodb、Memory、MERGE

- **MYISAM：**`全表锁`，拥有较高的执行速度，`不支持事务`，`不支持外键`，`并发性能差`，`占用空间相对较小`，`对事务完整性没有要求`，以select、insert为主的应用基本上可以使用这引擎。
- **InnoDB：**`行级锁`，提供了具有`提交、回滚和崩溃回复能力的事务安全`，`支持自动增长列`，`支持外键约束`，`并发能力强`，占用空间是MYISAM的2.5倍，处理效率相对会差一些。
- **Memory：**`全表锁`，存储在内容中，速度快，但会占用和数据量成正比的内存空间且数据在mysql重启时会丢失，默认使用HASH索引，检索效率非常高，但不适用于精确查找，主要用于那些内容变化不频繁的代码表。
- **MERGE：**是一组MYISAM表的组合

## 3、数据库的事务？（ACID是什么）

**什么是事务：**多条SQL语句，`要么全部成功，要么全部失败`。

**事务的特性：**数据库的事务特性有`原子性（Atomic）`、`一致性（Consistency）`、`隔离性（Isolation）`、`持久性（Durailiy）`，简称**ACID**。

- **原子性：**组成一个事务的多个数据库操作是一个`不可分割的原子单元`，必须所有操作都成功，事务才会提交。任何一个操作失败，已经执行的任何操作都必须`撤销`，让数据库返回初始状态。
- **一致性：**事务操作成功后，`数据库所处的状态和它的业务规则是一致的`。即数据不会被破坏。如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。
- **隔离性：**在并发数据操作时，不同的事务拥有各自的数据空间，它们的`操作不会对彼此产生干扰`。
- **持久性：**一旦事务提交成功，事务中的`所有操作都必须持久化到数据库中`。

##4、数据库的索引是什么？

MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以`大大提高MySQL的检索速度`。索引相当于一本书的目录，能加快数据库的查询速度。

索引也是`一张表`，该表保存了`主键`与`索引字段`，并`指向实体表的记录`。一般来说，索引本身很大，不可能全部存储在内存中，因此索引往往是存储在磁盘上的文件中的（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。

索引包括`聚簇索引`、`覆盖索引`、`组合索引`、`前缀索引`、`唯一索引`等，没有特别说明，默认都是`使用B+树结构组织（多路搜索树，并不一定是二叉树）的索引`。

**缺点：**索引可`大大提高查询速度`，同时去也会`降低更新表的速度`，如对表进行INSERT、UPDATE和DELETE。在更新表时，MySql不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。

#### 索引的分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

## 5、说说InnoDB与MyISAM的区别？

1. **InnoDB支持事务，MyISAM不支持**，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
2. **InnoDB支持外键，而MyISAM不支持**。对一个包含外键的InnoDB表转为MYISAM会失败；
3. **InnoDB是聚簇索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高**。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
5. **Innodb不支持全文索引，而MyISAM支持全文索引**，查询效率上MyISAM要高；（从MySQL5.6版本开始，InnoDB支持全文索引）
6. MyISAM不支持行级锁。MyISAM会对整张表加锁，而不针对行。同时，MyISAM不支持事务和外键。MyISAM可被压缩，存储空间较小，而且MyISAM在筛选大量数据时非常快。

## 6、SQL优化方案？

1. 查询语句中不要使用select *

2. 尽量减少子查询，使用关联查询（left join,right join,inner join）替代

3. 减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代

4. or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好) 

5. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

6. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： `select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0`

## 7、说说drop、delete和truncate的区别？

**delete和truncate**只`删除表的数据`而`不删除表的结构`，速度一般来说：`drop>truncate>delete`。delete语句是dml，这个操作会放到rollback segement中，事务提交之后才生效。如果有相应的trigger（触发器），执行的时候将被触发。

truncate和drop是ddl，操作立即生效，原数据不放到rollback segment中，不能回滚，操作不能触发trigger。

- DML（data manipulation language）是数据操纵语言：它们是SELECT、UPDATE、INSERT、DELETE，就象它的名字一样，这4条命令是用来对数据库里的数据进行操作的语言。
- DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。
- DCL（DataControlLanguage）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。

## 8、什么是视图？

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。

## 9、什么内联接、左外联接、右外联接？

- **内联接（Inner Join）：**匹配两张表中`相关联`的记录。
- **左外联接（Left Outer Join）：**除了两张表中相关联的记录外，还会匹配`左表中剩余的记录`，右表中未匹配的字段`用NULL表示`。
- **右外联接（Right Outer Join）：**除了匹配两张表中相关联的记录外，还会匹配`右表中剩余的记录`，左表中未匹配的字段`用NULL表示`。在判定左表和右表时，要根据`表名出现在Outer Join的左右位置关系`。

## 10、并发事务带来的问题？

多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能出现的问题：

- **脏读（Dirty read）：**当一个事务正在访问数据并且对数据进行了修改，但是这个修改还`没有提交到数据库中`。此时，另外一个事务也访问了这个数据，然后使用该数据。该`数据是未提交的数据`，所以`另外一个事务读到的数据是”脏数据“`。
- **丢失修改（Lost to modify）：**指`在一个事务读取一个数据时，另外一个事务也访问了该数据`。在第一个事务中修改了这个数据后，第二个事务也修改了这个数据，导致第一个事务`修改的数据被覆盖`，结果丢失，也称为`丢失修改`。
- **不可重复读（UnRepeatable Read）：**在`一个事务内多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该数据`。此时，在第一个事务的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据不一致。出现了一个事务内两次读到的数据不一致的情况。(更新操作)
- **幻读（Phantom Read）：**幻读与不可重复读类似。发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）`插入了一些数据时`。在随后的查询中，第一个事务（T1）就会发现`多了一些原本不存在的记录`，就好像发生了幻觉一样。所以称为幻读。(增删操作)

> 不可重复读与幻读的区别？

**不可重复读**的重点是`修改`，比如多次读取一条记录发现其中某些列的值被修改

**幻读**的重点在于`新增或者删除`，比如多次读取一条记录发现记录增多或减少了。

## 11、事务隔离级别有哪些？

- **读未提交：**最低的隔离级别，允许`读取未提交的数据变更`。可能会导致`脏读、不可重复读、幻读`。
- **读已提交：**允许`读取并发事务已经提交的数据`。`不会发生脏读`，但是`可能发生不可重复读和幻读`。
- **可重复读：**`对同一字段的多次读取结果都是一致的`，除非数据是被本身事务自己修改的。可以`阻止脏读和不可重复读，但幻读可能发生`。
- **可串行化：**最高的隔离级别，完全服从ACID的隔离级别。所有的`事务依次逐个执行`，这样`事务之间完全不可能产生干扰`。该隔离级别可以`防止发生脏读、不可重复读和幻读`。

## 12、大表优化

当MySQL单表记录数过大时，数据库的`CURD性能会明显下降`，优化措施

> **1、限定数据的范围**

务必禁止`不带任何数据范围条件`的查询语句。例如：当用户在查询订单历史的时候，可以控制在一个月的范围内。

> **2、读/写分离**

经典的数据库拆分方案，`主库负责写，从库负责读`。

> **3、垂直分区**

根据数据库里面数据表的相关性进行拆分。例如：用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

简单来说垂直拆分就是指`数据表列的拆分`，把一张列比较多的表拆分为多张表。

- **垂直拆分的优点：**可以使得列数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂直分区可以简化表的结构，易于维护。
- **垂直拆分的缺点：**主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。

> **4、水平分区**

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以将一张表的数据拆成多张表来存放。例子：可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一机器上，其实对于提升MySQL并发能力没有什么意义。因此，水平拆分最好分库。

水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决，跨节点Join性能较差，逻辑复杂。

**数据库分片的两种常见方案：**

- **客户端代理：**分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。
- **中间件代理：**在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。

[MySQL大表优化方案](https://segmentfault.com/a/1190000006158186)

## 13、分库分表之后，ID主键如何处理？

分层多表之后，每个表都是从1开始累加，这样是不对的。我们需要一个全局唯一的id来支持。

生成全局id有下面这几种方式：

- **UUID：**不适合作为主键，因为太长了，并且`无序不可读，查询效率低`。比较适合用于生成唯一的名字的标示比如文件的名字。
- **数据库自增ID：**两台数据库分别设置`不同步长，生成不重复ID的策略`来实现高可用。这种方式生成的ID有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
- **利用Redis生成ID：**性能比较好，灵活方便，不依赖于数据库。但是，在引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增量系统成本。
- **Twitter的snowflake算法：**
- **美团的Leaf分布式ID生成系统：**Leaf是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全。https://tech.meituan.com/2017/04/21/mt-leaf.html

## 14、说说在MySQL中一条查询SQL是如何执行的？

```sql
select name from t_user where id=1;
```

1. **取得链接：**使用到MySQL中的连接器。
2. **查询缓存：**key为SQL语句，value为查询结果，如果查到就直接返回。不建议使用次缓存，在MySQL8.0版本已经将查询缓存删除，也就是说MySQL8.0版本后不存在此功能。
3. **分析器：**分为词法分析和语法分析。此阶段只是做一些 SQL 解析，语法校验。一般语法错误在此阶段被检测出。
4. **优化器：**是在表里有多个索引的时候，决定使用哪个索引；或者一个语句中存在多表关联的时候（Join），决定各个表的连接顺序。
5. **执行器：**通过分析器让 SQL 知道你要干啥，通过优化器知道该怎么做，于是开始执行语句。执行语句的时候还要判断是否具备此权限，没有权限就直接返回提示没有权限的错误；权限则打开表，根据表的引擎定义，去使用这个引擎提供的接口，获取这个表的第一行，判断id是都等于1。如果是，直接返回；如果不是继续调用引擎接口去下一行，重复相同的判断，直到这个表的最后一行，最后返回。

## 15、索引有什么优缺点？

**优点：**

- 提高数据的检索速度，降低数据库IO成本；使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。
- 降低数据排序的成本，降低CPU消耗；索引之所以查的快。是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本。

**缺点：**

- 占用存储的空间：索引实际上也是一张表，记录了主键与索引字段。一般以索引文件的形式存储在磁盘上。
- 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。

## 16、varchar和char的区别？varchar（30）中的30代表的涵义？

varchar是`可变长度`的类型，char是`固定长度`的类型；varchar节省了存储空间，对性能也有帮助。

varchar(30)中30的涵义最多存放30个字符。varchar(30)和(130)存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 ORDER BY col采用 fixed_length 计算 col长度（memory引擎一样）。

**对效率要求高用 char，对空间使用要求高用 varchar。**

## 17、为什么 SELECT COUNT(*) FROM table 在InnoDB比MyISAM慢？

对于 SELECT COUNT(*) FROM table语句，在没有 WHERE 条件的情况下，InnoDB比MyISAM可能会慢很多，尤其是在大表的情况下。因为InnoDB是去实时统计结果会**全表扫描**；而MyISAM内部维持了一个计数器，预存了结果，所以直接返回即可。

## 18、MySQL索引类型有哪些？

- **主键索引：**索引列中的值必须是唯一的，不允许有空值。
- **普通索引：**MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
- **唯一索引：**索引列中的值必须是唯一的，但是允许为空值。
- **全文索引：**只能在文本类型CHAR、VARCHAR、TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率较低，这时可以创建全文索引。
- **空间索引：**MySQL在5.7之后的版本支持了空间索引，而且支持了OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。
- **前缀索引：**在文本类型如CHAR、VARCHAR、TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。

## 19、什么时候不要使用索引？

- `经常增删改的列`不要建立索引。
- 有`大量重复的列`不建立索引。
- `表记录太少`不要建立索引。

## 20、说说什么是MVCC？

**多版本并发控制**（MVCC=Multi-Version Concurrency Control），是一种用来`解决读-写冲突的无锁并发控制`。为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。这样在读操作不要阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。

## 21、MVCC可以为数据库操作解决什么问题？

在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的能力。`同时还可以解决脏读、幻读、不可重复读等事务隔离问题`，但`不能解决更新丢失问题`（一个事务更新时，另一个事务也紧接着更新，将第一个事务的结果覆盖）。

## 22、说说MVCC的实现原理？

MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的3个隐式字段、undo日志、Read View来实现的。

## 23、说说MySQL数据库的锁？

MySQL中有共享锁和排他锁（读锁和写锁）

1. **共享锁：**不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响。
2. **排他锁：**一个写操作阻塞其他的读锁和写锁，这样只允许一个用户进行写入，防止其他用户读取正在写入的资源。
3. **表锁：**系统开销最小，会锁定整张表，MyISAM使用表锁。
4. **行锁：**容易出现死锁，发生冲突概率低，并发高。InnoDB支持行锁（必须有索引才能实现，否则会自动锁全表，那么就不行锁了）。

## 24、说说什么是锁升级？

- MySQL行锁只能加在索引上，如果操作不走索引，就会升级为表锁。因为InnoDB的行锁是加在索引上的，如果不走索引，自然就没法使用行锁了。原因是InnoDB是将 primary key index和相关的行数据共同放在B+树的叶节点。InnoDB一定会有一个 primary key，secondary index查找的时候，也是通过找到对于的 primary，再找到对于的数据行。
- 当非唯一索引上记录数超过一定数量时，行锁也会升级为表锁。当非唯一索引相同的内容不少于整个表记录的二分之一时会升级为表锁。因为当非唯一索引相同的内容达到整个记录的二分之一时，索引需要的性能比全文检索还要大，查询语句优化时会选择不走索引，造成索引失效，行锁自然就会升级为表锁。

## 25、说说悲观锁和乐观锁？

> **悲观锁**

数据库被外界（包括本系统当前的其他事物以及来自外部系统的事务处理）修改保持着保守态度，因此在整个数据修改过程中，将数据处于锁状态。悲观的实现往往是依靠数据库提供的锁机制，也只有数据库层面提供的锁机制才能真正保证数据访问的排他性。否则，即使在本系统汇总实现了加锁机制，也是没有办法保证系统不会修改数据。

在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其他事务就无法修改这些数据。修改删除数据时也需要加锁，其他事务无法读取这些数据。

> **乐观锁**

相对悲观锁来说，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但伴随的是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

乐观锁，大多是基于数据版本（Version）记录机制实现。何为数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对于记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

## 26、怎样尽量避免死锁的出现？

1. 设置获取锁的超时时间，至少能保证最差情况下可以退出程序，不至于一致等待导致死锁。
2. 设置按照同一顺序访问资源，类似于串行执行
3. 避免是事务中的用户交叉
4. 保持事务简短并在一个批处理中
5. 使用低隔离级别
6. 使用绑定链接

## 27、主键与索引的区别？

- 主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键
- 主键不允许为空值，唯一索引列允许空值
- 一个表只能有一个主键，但是可以有多个唯一索引
- 主键可以被其他表引用为外键，唯一索引列不可以
- 主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构

## 28、 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 MySQL 数据库，又插入了一条数据，此时 id 是几？

一般情况下，创建的表的类型是`InnoDB`，如果新增一条记录（不重启MySQL的情况下），那此时id是8；如果MySQL重启了，那此时id是6。因为`InnoDB表只把自增主键的最大ID记录到内存中`，重启MySQL或则对表OPTIMIZE操作，都会使最大ID丢失。

如果使用表的类型是`MyISAM`，那么这条记录的id是8。因为`MyISAM表会把自增主键的最大ID记录到数据文件里`，重启MySQL后，自增主键的最大ID也不会丢失。

## 29、MySQL类型float double decimal的区别

float数值类型用于表示`单精度浮点数值`，而double数值类型用于表示`双精度浮点数值`，`float和double`都是`浮点型`。`decimal`是`定点型`。

MySQL 浮点型和定点型可以用类型名称后加（M，D）来表示，M表示该值的总共长度，D表示小数点后面的长度，M和D又称为精度和标度，如float(7,4)的 可显示为-999.9999，MySQL保存值时进行四舍五入，如果插入999.00009，则结果为999.0001。

FLOAT和DOUBLE在不指 定精度时，默认会按照实际的精度来显示，而DECIMAL在不指定精度时，默认整数为10，小数为0

## 30、MySQL索引是如何实现的？

先了解几种树的数据结构

> **二叉搜索树**

二叉搜索树的性质：

1. 每个节点有一个关键字。
2. 左右孩子至多有一个。
3. 关键字大于左孩子，小于右孩子。

二叉搜索树的特性，很适合用来做搜索，效率等同于二分查找，时间复杂度为log2(n)。

![image-20220730170446827](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207301705328.png)

二叉搜索树的节点中存储键(key)和数据(data)。数据对应user表中的行数据。查找ID为9的用户信息，流程如下：

1. 将根节点作为当前节点，9大于6，将6的右子节点（8）作为当前节点。
2. 9与8比较，将8的右子节点（9）作为当前节点。
3. 9与9比较，满足条件。

> **极端情况下二叉搜索树会退化成了一个链表**

查找id为9的用户信息，需要查找6次，相当于全表扫描。导致该现象的原因是因为二叉查找树不平衡了。可使用`平衡二叉树`解决该问题。**平衡二叉树**又称AVL树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过1。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207301726812.png" alt="image-20220730172604245" style="width:30%;" />

> **B树**

因为内存的易失性，一般会将数据和索引存储到磁盘中。但是和内存相比，从磁盘中读取数据会慢很多，应当减少数据读取次数。从磁盘读数据按照磁盘块来读取，而非一条一条的读。

将尽可能多的数据放进磁盘中，那一次磁盘读取操作就会读取到更多数据。且查找数据的时间也会大幅度降低。假设用平衡二叉树作为索引的数据结构，每次查找数据的时候都会从磁盘中读取一个节点。由于平衡二叉树每个节点只存储一个键值和数据，二叉树的节点将会非常多，高度也会极其高，查找数据时也会进行很多次磁盘IO，查找效率将会降低。

因此引入B树的数据结构，它的性质

1. 根节点至少有两个孩子，根节点孩子数为[2,m]
2. 除根节点外每个非叶子节点的孩子数为[m/2,m]（向上取整）
3. 非叶子节点的关键字个数 = 指向孩子的指针树-1
4. 所有叶子节点在同一层且关键字个数为k-1，其中m/2 <= k <= m
5. 节点之间关键字的大小，类比二叉搜索树，即关键字的值按大小排列，pi的关键字的值属于（k[i],k[i+1]）开区间，例如 p2的关键字要大于17，小于35。

![image-20220730210043598](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207302101162.png)

> B+ 树

B+树建立在B树的基础基础上，更改了几条性质。B+树在B-树的基础上添加了叶子链表指针，方便查找相邻的数据。所有的数据只有在叶子节点才会被命中，非叶子节点只提供索引，如此非叶子节点可以存储更多的数据。

1. 非叶子节点的关键字和孩子指针数相同
2. pi的关键字的值属于[k[i],k[i+1]]闭区间
3. 为叶子节点添加一个指针

![image-20220730210443121](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207302104941.png)

> B+索引实现原理

MySQL存储索引的文件以页为单位，一个节点相当于一页。不同的存储引擎，索引实现也不同，就以InnoDB来说，默认一个索引页为16KB，MySQL在查询索引时，会预先把多个页加载到内存中。所以如果索引的键很大的话，会引起索引的列表，产生很多的碎片，因为如果一页存储不下一个节点的话，就会新开另外一页。

## 31、如何验证MySQL的索引是否满足需求？

使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。

```sql
explain select * from tableName where type=1;
```

