# Redis相关面试题

## 1、为什么要使用缓存？

使用缓存主要是为了**提升读写性能**。在实际业务情景下，更多的是为了提升读性能，带来`更好的性能`，带来`更高的并发量`。由于`Redis`的读写性能比`Mysql`好的多，可以把`Mysql`中的`热点数据缓存`到`Redis`中，提升读取性能，同时减轻Mysql的读写压力。

## 2、Redis的好处？

- `读取速度快`：数据存储在内存中。
- 支持`多种数据结构`：包括`String（字符串）`、`list（链表）`、`set（集合）`、`zset（有序集合）`、`hash（哈希类型）`等。
- 支持`事务`，且操作`遵守原子性`，即对数据的操作要么都执行，要么都不支持。
- 还拥有其他丰富的功能，`队列`、`主从复制`、`集群`、`数据持久化`等。

## 3、什么是Redis？

Redis 是一个开源（BSD 许可）、基于`内存`、支持`多种数据结构`的存储系统，可以作为`数据库`、`缓存`和`消息中间件`。它支持的数据结构有`字符串（strings）`、`哈希（hashes）`、`列表（lists）`、`集合（sets）`、`有序集合（sorted sets）`等，除此之外还支持 `bitmaps`、`hyperloglogs `和`地理空间（geospatial ）索引半径查询`等功能。它内置了主从复制（Replication）、LUA 脚本（Lua scripting）、LRU 驱动事件（LRU eviction）、事务（Transactions）和不同级别的磁盘持久化（persistence）功能，并通过 Redis 哨兵（哨兵）和集群（Cluster）保证缓存的高可用性（High availability）。

## 4、为什么使用Redis而不是Memcache呢？

- `Redis`和`Memcache`都是将`数据存放在内存中`，都是`内存数据库`。不过Memcache还可用于缓存其他东西，例如图片、视频等。
- Memcache仅支持`key-value结构的数据类型`；Redis不仅仅支持简单的key-value类型的数据，同时还提供list、set、hash等数据结构的存储。
- `虚拟内存`：Redis当物理内存用完时，可以将一些很久没用到的value交换到磁盘。
- `分布式`：设定Memcache集群，利用magent做一主多从；Redis可以做一主多从，也可以一主一从。
- `存储数据安全`：Memcache挂掉后，数据没了；Redis可以定期保存到磁盘（持久化操作）。
- `单个value大小`：Memcache的单个value最大1m；Redis的单个value最大512m。
- `灾难恢复`：Memcache挂掉后，数据不可恢复；Redis数据丢失后可以通过 aof 恢复。
- Redis原生就支持集群模式，Redis3.0版本中，官方便能支持Cluster模式了；Memcache没有原生的集群模式，需要依赖客户端来实现，然后往集群中分片写入数据。
- `网络模型`：`Memcache网络IO模型是多线程，非阻塞IO复用的网络模型`，原型上接近于Nginx。而`Redis使用单线程的IO复用模型`，自己封装了一个简单的AeEvent事件处理框架，主要实现类epoll、kqueue和select，更接近于Apache早期的模式。

## 5、为什么Redis单线程模型效率也能那么高？

- C语言实现，效率高
- 纯内存操作
- 基于非阻塞的IO复用模型机制
- 单线程的话就能避免多线程的频繁上下文切换问题
- 丰富的数据结构（采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如压缩表，跳表等）

## 6、说说Redis的线程模型？

Redis内部使用文件事件处理器，这个文件事件处理器是单线程的。采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。

文件事件处理器包含四部分：

1. 多个socket。
2. IO多路复用机制。
3. 文件事件分派器。
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。

多个socket可能会并发产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，会将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

![image-20220723104453165](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207231045246.png)

**客户端与Redis通信一次的流程：**

1. 客户端Socket01向Redis的Server Socket请求建立连接，此时Server Socket会产生一个AE_READABLE事件，IO多路复用程序监听到Server Socket产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的Socket01，并将该Socket01的AE_READABLE事件与命令请求处理器关联。
2. 假设此时客户端发送了一个 set key value请求，此时Redis中的Socket01会产生AE_READABLE事件，IO多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面Socket01的AE_READABLE事件已经与命令请求处理器关联。因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取Socket01的set key value并在自己内存中完成set key value的设置。操作完成后，它会将Socket01的AE_READABLE事件与命令回复处理器关联。
3. 如果此时客户端准备好接收返回结果了，那么Redis中的Socket01会产生AE_READABLE事件，同样压入队列中，事件分派器找到相关联的命令回复处理器。由命令回复处理器对Socket01输入本次操作的一个结果，比如ok，之后解除Socket01的AE_READABLE事件与命令回复处理器的关联。

## 7、为什么Redis需要把所有数据放到内存中？

Redis将数据放在内存中有一个好处，可以实现最快的对数据读取。如果数据存储在硬盘中，磁盘I/O会严重影响Redis的性能。且Redis还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。

## 8、说说Redis的同步机制？

Redis支持主从同步、从从同步。如果是第一次进行主从，主节点需要使用bgsave命令，再将后续修改操作记录到内存的缓冲区，等RDB文件全部同步到复制节点，复制节点接收完成后将RDB镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。

## 9、pipeline有什么好处？为什么要用pipeline？

使用pipeline（管道）的好处在于可以将多次I/O往返的时间缩短为一次，但是要求管道中执行的指令间没有因果关系。

用pipeline的原因在于可以实现请求/响应服务器的功能，当客户端未读取旧响应时，它也可以处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应才能执行下个命令，只需最后一步从服务端读取回复即可。

## 10、说说Redis有什么优点和缺点？

**优点：**

- 速度快：因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。
- 支持丰富的数据结构：支持String、list、set、zset、hash五种基础的数据结构。
- 持久化存储：Redis提供RDB和AOF两种数据的持久化存储方案，解决内存数据库最担心的万一Redis挂掉，数据会消失掉。
- 高可用：内置Redis Sentinel，提供高可用方案，实现主从故障自动转移。内置Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的Redis规模。
- 丰富的特性：Key过期、计数、分布式锁、消息队列等。

**缺点：**

- 由于Redis是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然Redis本身有Key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
- 如果进行完整重同步，由于需要生成RDB文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。在Redis2.8版本中，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如新上线的备机。
- 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis不能提供服务。

## 11、Redis缓存刷新策略有哪些？

- LRU/LFU/FIFO算法剔除：当Redis memory达到最大值的时候，首先关注的是过期的数据，通过删除策略来达到保护内存的效果。这种方式只需要关注缓存的策略配置，不需要关心具体的每一个key到底是怎么过期的，每一个key到底是怎么被删除的。
- 超时剔除：设置过期时间
- 主动更新：开发控制生命周期

## 12、Redis持久化方式有哪些？以及有什么区别？

Redis提供两种持久化机制RDB和AOF。

### RDB持久化机制

是指用数据集快照的方式半持久化模式记录Redis数据库的所有键值对，在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上传持久化的文件。达到数据恢复。

**优点：**

- 只有一个文件dump.rdb，方便持久化。
- 容灾性好，一个文件可以保存到安全的磁盘。
- 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能。
- 相对于数据集大时，比AOF的启动效率更高。

**缺点：**

数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间Redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。

### AOF=Append-only file持久化方式

是指所有的命令行记录以Redis命令请求协议的格式完全持久化存储，保存为AOF文件。

**优点：**

- 数据安全，AOF持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到AOF文件中一次。
- 通过append模式写文件，即使途中服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。
- AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）

**缺点：**

- AOF文件比RDB文件大，且恢复速度慢。
- 数据集大的时候，比RDB启动效率低。

## 13、怎么样选择持久化？

- 不要仅仅使用RDB，因为那样会导致丢失很多数据。
- 也不要仅仅使用AOF，因为那样有两个问题，第一：通过AOF做冷备没有RDB做冷备的恢复速度更快。第二：RDB每次简单粗暴生成数据快照，更加健壮，可以避免AOF这种复杂的备份和恢复机制的bug。
- Redis支持同时开启两种持久化方式，可以综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或损坏不可用的时候，还可以使用RDB来进行快速的数据恢复。
- 如果同时使用RDB和AOF两种持久化机制，那么在Redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整。

## 14、怎么使用Redis实现消息队列？

一般使用`lsit`结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

- 可不可以不用sleep？list还有个指令叫`blpop`，在没有消息的时候，会阻塞住直到消息的到来。
- 能不能生产一次消费多次？使用pub/sub主题订阅者模式，可以实现`1：N的消息队列`。
- pub/sub有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列（RabbitMQ）等。
- Redis如何实现延时队列？使用`zset（sortedset）`，拿`时间戳作为score（权重）`，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

## 15、说说对Redis事务的理解？

### 什么是Redis事务？原理是什么？

Redis中的事务是一组命令的集合，是Redis的最小执行单位。它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。

原理是先将属于一个事务的命令发送给Redis，然后依次执行这些命令。

### Redis事务的注意点有哪些？

- Redis事务是不支持回滚的，不像Mysql的事务一样，要么都执行要么都不执行。
- Redis服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。直到事务命令全部执行完毕才会执行其他客户端的命令。

### Redis事务为什么不支持回滚？

Redis的事务不支持回滚，但是执行的命令有语法错误，Redis会执行失败。这些问题可以从程序层面捕获并解决。但是如果出现其他问题，则依然会继续执行余下的命令。如此做的原因是因为回滚需要增加很多工作，而不支持回滚则可以保持简单、快速的特性。