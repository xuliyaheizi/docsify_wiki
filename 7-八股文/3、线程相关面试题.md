# 线程相关面试题

## 一、线程基础

### 1.1、多线程的出现是要解决什么问题的?

- **发挥多核CPU的优势**

  多线程，可以真正发挥多核CPU的优势来，达到充分利用CPU的目的，采用`多线程的方式去同时完成几件事情而不互相干扰`。

- **防止阻塞**

  从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，降低程序整体的效率。但是单核CPU还是要应用多线程，就是为了防止阻塞。（假如单核CPU使用单线程，只要这个线程阻塞了，比如说远程读取某个数据，对端迟迟未返回又没有设置超时时间，此时整个程序在数据返回回来之前就停止运行了）

  多线程有效的防止这个问题，多条线程同时运行，就算一条线程的代码执行读取数据阻塞了，也不会影响其它任务的执行。

- **便于建模**

  假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。如果将这个大的任务分解成几个小任务，多个任务分别建立程序模型，并通过多线程运行，那就简单挺多。

### 1.2、线程不安全是指什么? 举例说明

- 线程安全：指多个线程在执行同一段代码的时候采用锁机制，使每次执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。
- 线程不安全：指不提供锁机制，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。
- 举例：例如售票系统，有票100张，在多线程情况下，用户A和用户B都来买票，如果多线程没有采用锁机制，就会线程不安全，出现100-1同时执行的情况，最终A和B买完票后剩下99张票，而不是98张。
- 引起线程不安全的原因：线程安全问题是由全局变量及静态变量引起的；如果每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，此时就需要考虑线程同步的问题，否则可能会影响线程安全。

### 1.3、并发出现线程不安全的本质什么? 可见性，原子性和有序性。

多线程并发时会不安全，多线程同时操作对象的属性或者状态时，会因为线程之间的信息不同步，A线程读取到的状态已经过时，而A线程并不知道，导致产生线程不安全。所以并发时出现线程不安全的本质是**线程之间的信息不同步**。

**可见性：**在多线程中，若线程A中进行的每一步都可以被线程B观测到，则称线程A对线程B具有可见性；线程B不仅可以看到线程A处理的结果，还能准确的知道在处理过程中，每一个状态的改变，已经状态改变的顺序。Java线程的通讯是透明的，线程之间不可以直接进行信息交换，所有的信息必须同内存共享。因此多线程是天然不可见的。也就是在不主动干涉的情况下，线程之间是不可见的。线程之间不可见是因为线程本身没有直接通讯机制，线程可以通过主内存进行数据交换，也可以说线程之间可通过内存通讯。

**有序性：**在java中，单线程总是顺序执行的。当编译器和处理器重排序时，必须保证，不管怎么重排序，单线程的执行结果不能被改变。

**原子性：**一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么都不执行。

#### Java的线程内存模型

Java线程模型由主内存和工作内存组成。

![1328967-20190605221210905-58853278](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207170917780.png)

- 工作内存和主内存两部分一起组成Java的线程模型
- 工作内存是属于线程的，不同线程的工作内存之间不可共享，不可通讯
- 工作内存通过Load操作从主内存中读取数据，通过Save操作将数据写入主内存
- 线程之间的通讯：本质上是指通过主内存的数据共享

### 1.4、Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before

**思路与手段**

- 扩容：水平扩容、垂直扩容
- 缓存：Redis、Memcache、GuavaCache等
- 队列：kafka、RabitMQ、RocketMQ等
- 应用拆分：服务化Dubbo和微服务Spring Cloud
- 限流：Guava RateLimiter使用、常用限流算法、自己实现分布式限流等
- 服务降级与服务熔断：服务降级的多重选择、Hystrix
- 数据库切库、分库分表：切库、分表、多数据源
- 高可用的一些手段：任务调度分布式elastic-job、主备curator的实现、监控报警机制

**CPU多级缓存：**缓存一致，乱序执行优化

**Java内存模型：**JMM规定，抽象结构，同步操作与规则

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态
- unlock（解锁）：作用于主内存变脸个，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以遍随后的write的操作
- write（写入）：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

#### JMM内存模型的同步规则

1. 如果要把一个变量从主内存中复制到工作内存，就需要按顺序的执行read和load操作，如果把变量从工作内存中同步回主内存，就需要按顺序的执行store和write操作。但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行
2. 不允许read和load、store和write操作之一单独出现
3. 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中
4. 不允许一个线程无原因的（没发生过任何assign操作）把数据从工作内存同步回主内存中
5. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作
6. 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现
7. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值
8. 如果一个变量实现没有被lock操作锁定，怎不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量
9. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

#### 有序性——happens-before原则

1. `程序次序规则`：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

   注：在单线程中，看起来是这样的，虚拟机可能会对代码进行指令重排序，虽然重排序了，但是运行结果在单线程中和指令书写顺序是一致的，事实上，这条规则是用来保证程序单在单线程中执行结果的正确性，无法保证程序在多线程中的正确性

2. `锁定规则`：一个unlock操作先行发生于后面对同一个锁的lock操作

3. `volatile变量规则`：对一个变量的写操作先行发生于后面对这个变量的读操作

4. `传递规则`：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

   前四条规则比较重要

5. `线程启动规则`：Thread对象的start()方法先行发生于次线程的每一个动作

6. `线程中断规则`：对线程interrupt()方法的调用先行发生于被中断线程的代码监测到中断事件的发生

7. `线程终结规则`：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行

8. `对象终结规则`：一个对象的初始化完成先行发生于他的finalize()方法的开始

### 1.5、线程安全是不是非真即假? 不是

`线程安全性不是一个非真即假的命题`。 Vector 的方法都是同步的，并且 Vector 明确地设计为在多线程环境中工作。但是它的线程安全性是有限制的，即在某些方法之间有状态依赖(类似地，如果在迭代过程中 Vector 被其他线程修改，那么由 Vector.iterator() 返回的 iterator会抛出ConcurrentModifiicationException)。
对于 Java 类中常见的线程安全性级别，没有一种分类系统可被广泛接受，不过重要的是在编写类时尽量记录下它们的线程安全行为。
Bloch 给出了描述五类线程安全性的分类方法：不可变、线程安全、有条件线程安全、线程兼容和线程对立。只要明确地记录下线程安全特性，那么您是否使用这种系统都没关系。这种系统有其局限性 -- 各类之间的界线不是百分之百地明确，而且有些情况它没照顾到 -- 但是这套系统是一个很好的起点。这种分类系统的核心是调用者是否可以或者必须用外部同步包围操作(或者一系列操作)。下面几节分别描述了线程安全性的这五种类别。

- **不可变：**不可变的对象一定是线程安全的，并且永远也不需要额外的同步[1] 。因为一个不可变的对象只要构建正确，其外部可见状态永远也不会改变，永远也不会看到它处于不一致的状态。Java 类库中大多数基本数值类如 Integer 、 String 和 BigInteger 都是不可变的。
  需要注意的是，对于Integer，该类不提供add方法，加法是使用+来直接操作。而+操作是不具线程安全的。这是提供原子操作类AtomicInteger的原。
  线程安全
  线程安全的对象具有在上面“线程安全”一节中描述的属性 -- 由类的规格说明所规定的约束在对象被多个线程访问时仍然有效，不管运行时环境如何排线程都不需要任何额外的同步。这种线程安全性保证是很严格的 -- 许多类，如 Hashtable 或者 Vector 都不能满足这种严格的定义。
- **有条件的：**有条件的线程安全类对于单独的操作可以是线程安全的，但是某些操作序列可能需要外部同步。条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的迭代器 -- 由这些类返回的 fail-fast 迭代器假定在迭代器进行遍历的时候底层集合不会有变化。为了保证其他线程不会在遍历的时候改变集合，进行迭代的线程应该确保它是独占性地访问集合以实现遍历的完整性。通常，独占性的访问是由对锁的同步保证的 -- 并且类的文档应该说明是哪个锁(通常是对象的内部监视器(intrinsic monitor))。
  如果对一个有条件线程安全类进行记录，那么您应该不仅要记录它是有条件线程安全的，而且还要记录必须防止哪些操作序列的并发访问。用户可以合理地假设其他操作序列不需要任何额外的同步。
- **线程兼容：**线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用。这可能意味着用一个 synchronized 块包围每一个方法调用，或者创建一个包装器对象，其中每一个方法都是同步的(就像 Collections.synchronizedList() 一样)。也可能意味着用 synchronized 块包围某些操作序列。为了最大程度地利用线程兼容类，如果所有调用都使用同一个块，那么就不应该要求调用者对该块同步。这样做会使线程兼容的对象作为变量实例包含在其他线程安全的对象中，从而可以利用其所有者对象的同步。
  许多常见的类是线程兼容的，如集合类 ArrayList 和 HashMap 、 java.text.SimpleDateFormat 、或者 JDBC 类 Connection 和 ResultSet 。
- **线程对立：**线程对立类是那些不管是否调用了外部同步都不能在并发使用时安全地呈现的类。线程对立很少见，当类修改静态数据，而静态数据会影响在其他线程中执行的其他类的行为，这时通常会出现线程对立。线程对立类的一个例子是调用 System.setOut() 的类。

### 1.6、线程安全有哪些实现思路?

**思路：**

1. 给共享的资源加锁，保证每个资源变量每时每刻至多被一个线程占用。
2. 让线程也拥有资源，不用去共享进程中的资源。

**实现方案：**

1. 多实例或者多副本（ThreadLocal）：对于思路2，ThreadLocal可以为每个线程维护一个私有的本地变量
2. 使用锁机制（synchronize、lock方式）：为资源加锁
3. 使用java.util.concurrent下面的类库：有JDK提供的线程安全的集合类

### 1.7、如何理解并发和并行的区别?

**并发基本概念：**同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程将交替的换入或换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态。如果运行在多核处理器上，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。`多个线程操作相同的资源，保证线程安全，合理使用资源`

**高并发的概念：**高并发是互联网分布式系统架构设计中必须考虑的因素之一，通常是指，通过设计保证系统能够同时并行处理很多请求。`服务能同时处理很多请求，提高程序性能（更多的考虑技术手段）`。

### 1.8、线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?

#### 线程的状态

1. `初始（New）`：新创建一个线程对象，但还没有调用`start()`方法。
2. `运行（Runnable）`：将就绪（ready）和运行中（running）两种状态笼统的称为“运行”，线程对象创建后被其他线程（main线程）调用`start()`方法后，该线程位于可运行的线程池中，等待被线程调度选中，获取CPU的使用权，此时处于`就绪状态`。就绪状态的线程在获得CPU时间片后变为`运行中状态`。
3. `阻塞（BLOCKED）`：线程阻塞于锁。
4. `等待（Waiting）`：进入该状态的线程需要等待其他线程做出一些特定动作。（通知或中断）
5. `超时等待（Timed_Waiting）`：该状态不同于等待状态，可在指定的时间后自行返回。
6. `终止（Terminated）`：该线程已经执行完毕。

### 1.9、通常线程有哪几种使用方式?

创建线程的三种常见方式：1、继承Thread类；2、实现Runnable接口；3、实现Callable接口（jdk1.5>=）；4、线程方式创建

#### 采用实现Runnable、Callable接口的方式创建线程的优缺点

**优点：**线程类只是实现了Runnable或者Callable接口，还可以继承其他类。此时，多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想

**缺点：**编程稍微复杂，若需要访问当前线程必须使用`Thread.currentThread()`方法

#### 采用继承Thread类的方式创建线程的优缺点

**优点：**编写简单，可以直接使用`this`获取当前线程

**缺点：**丢失了类的扩展性，由于Java的单继承的机制，不能再继承其他父类

### 1.10、基础线程机制有哪些?

Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种 Executor：

- CachedThreadPool：一个任务创建一个线程；
- FixedThreadPool：所有任务只能使用固定大小的线程；
- SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。

#### Daemon

守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

main() 属于非守护线程。

在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。

```
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
```

#### sleep()

Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```
public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

#### yield()

对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

```
public void run() {
    Thread.yield();
}
```

### 1.11、线程的中断方式有哪些?

中断（Interrupt）一个线程意味着在该线程完成任务之前停止其正在进行的一切，有效地中止其当前的操作。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。

Thread.interrupt()方法: 作用是中断线程。将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。

interrupt()方法只是改变中断状态，不会中断一个正在运行的线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。这一方法实际完成的是，给受阻塞的线程发出一个中断信号，这样受阻线程检查到中断标识，就得以退出阻塞的状态。

更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。

- 使用 interrupt() + isInterrupted()来中断线程　　

### 1.12、线程的互斥同步方式有哪些? 如何比较和选择?

### 1.13、线程之间有哪些协作方式?

### 1.14、如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，也就是当run()方法运行完之后线程终止。
2. 使用stop方法强行终止，但是不推荐使用。因为stop、suspend和resume一样都是过期作废的方法。
3. 使用interrupt方法中断线程

```java
class MyThread extends Thread {
    volatile boolean stop = false;
    public void run() {
        while (!stop) {
            System.out.println(getName() + " is running");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("week up from blcok...");
                stop = true; // 在异常处理代码中修改共享变量的状态
            }
        }
        System.out.println(getName() + " is exiting...");
    }
}
class InterruptThreadDemo3 {
    public static void main(String[] args) throws InterruptedException {
        MyThread m1 = new MyThread();
        System.out.println("Starting thread...");
        m1.start();
        Thread.sleep(3000);
        System.out.println("Interrupt thread...: " + m1.getName());
        m1.stop = true; // 设置共享变量为true
        m1.interrupt(); // 阻塞时退出阻塞状态
        Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况
        System.out.println("Stopping application...");
    }
}
```

### 1.15、notify()和notifyAll()的区别？

- notify()可能会导致死锁，而notifyAll()不会
- 任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行`synchronized`中的代码。使用`notifyAll()`可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify()只能唤醒一个。
- wait()应配合while循环使用，不应该使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续使用wait()直至条件满足再往下执行。
- notify()是对notifyAll()的一个优化，但必须要有精确的应用场景，并且要求正确使用，否则会导致死锁。正确的场景应该是WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中。

### 1.16、sleep()和wait()有什么区别？

- sleep()方法是属于Thread类中的，而wait()是属于Object类中的。
- sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。
- 调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。

## 二、Synchronized面试题

- Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。
- Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。
- Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。
- Synchronized和Lock的对比，和选择?
- Synchronized在使用时有何注意事项?
- Synchronized修饰的方法在抛出异常时,会释放锁吗?
- 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?
- Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?
- 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?
- 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?
- 不同的JDK中对Synchronized有何优化?

## 三、volatile面试题

### 3.1、volatile是什么？可以保证有序性吗？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，将具备两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这值对其他线程来说是立即可见的。volatile关键字会强制将修改的值立即写入主存中。
2. 禁止指令重排集

volatile不是原子性操作。

#### 什么叫保证部分有序性？

当程序执行到volatile变量的读操作或写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

```java
x = 2; //语句1
y = 0; //语句2
flag = true; //语句3
x = 4; //语句4
y = -1; //语句5
```

由于flag变量为volatile变量，在进行指令重排序的过程的时候，不会改变语句3与其他的语句的顺序。但不是不能保证其他语句的顺序。

使用volatile一般用于状态标记量和单例模式的双检锁。

- volatile关键字的作用是什么?
- volatile能保证原子性吗?
- 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?
- i++为什么不能保证原子性?
- volatile是如何实现可见性的?  内存屏障。
- volatile是如何实现有序性的?  happens-before等
- 说下volatile的应用场景?
