# 线程相关面试题

## 一、线程基础

### 1.1、多线程的出现是要解决什么问题的?

- **发挥多核CPU的优势**

  多线程，可以真正发挥多核CPU的优势来，达到`充分利用CPU的目的`，采用`多线程的方式去同时完成几件事情而不互相干扰`。

- **防止阻塞**

  从程序运行效率的角度来看，单核CPU不但`不会发挥出多线程的优势`，反而会因为在单核CPU上运行多线程导致`线程上下文的切换`，`降低程序整体的效率`。但是单核CPU还是要应用多线程，就是为了`防止阻塞`。（假如单核CPU使用单线程，只要这个线程阻塞了，比如说远程读取某个数据，对端迟迟未返回又没有设置超时时间，此时整个程序在数据返回回来之前就停止运行了）。

  多线程有效的防止这个问题，多条线程同时运行，就算一条线程的代码执行`读取数据阻塞`了，也不会影响其它任务的执行。

- **便于建模**

  假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。如果将这个大的任务分解成几个小任务，多个任务分别建立程序模型，并通过多线程运行，那就简单挺多。

### 1.2、线程不安全是指什么? 举例说明

- 线程安全：指`多个线程`在执行`同一段代码`的时候采用`锁机制`，使每次执行结果和`单线程执行的结果都是一样的`，不存在执行程序时出现`意外结果`。
- 线程不安全：指`不提供锁机制`，有可能出现`多个线程先后更改数据造成所得到的数据是脏数据`。
- 举例：例如售票系统，有票100张，在多线程情况下，用户A和用户B都来买票，如果多线程没有采用锁机制，就会线程不安全，出现100-1同时执行的情况，最终A和B买完票后剩下99张票，而不是98张。
- 引起线程不安全的原因：线程安全问题是由`全局变量及静态变量`引起的；如果每个线程中对全局变量、静态变量`只有读操作，而无写操作`，一般来说，这个全局变量是线程安全的；若有多个线程`同时执行写操作`，此时就需要考虑`线程同步`的问题，否则可能会影响线程安全。

### 1.3、并发出现线程不安全的本质什么? 可见性，原子性和有序性。

多线程并发时会不安全，多线程同时操作对象的`属性或者状态`时，会因为线程之间的`信息不同步`，A线程读取到的`状态已经过时`，而A线程并不知道，导致产生线程不安全。所以并发时出现线程不安全的`本质是线程之间的信息不同步`。

**可见性：**在多线程中，若线程A中进行的`每一步都可以被线程B观测到`，则称线程A对线程B具有`可见性`；线程B不仅可以看到线程A处理的结果，还能准确的知道在处理过程中，每一个状态的改变，已经状态改变的顺序。Java线程之间的`通讯是透明`的，线程之间不可以直接进行信息交换，所有的信息必须通过`内存共享`。因此多线程是天然不可见的。也就是在不主动干涉的情况下，线程之间是不可见的。线程之间不可见是因为`线程本身没有直接通讯机制`，线程可以通过`主内存`进行`数据交换`，也可以说线程之间可通过内存通讯。

**有序性：**在java中，单线程总是`顺序执行`的。当`编译器和处理器重排序时`，必须保证，不管怎么重排序，单线程的执行结果不能被改变。

**原子性：**一个操作或者多个操作，要么`全部执行并且执行的过程不会被任何因素打断，要么都不执行`。

#### Java的线程内存模型

Java线程模型由`主内存`和`工作内存`组成。

![1328967-20190605221210905-58853278](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207170917780.png)

- `工作内存`和`主内存`两部分一起组成Java的线程模型。
- 工作内存是属于线程的，不同线程的工作内存之间`不可共享`，`不可通讯`。
- 工作内存通过`Load`操作从主内存中`读取数据`，通过`Save`操作将数据`写入主内存`。
- 线程之间的通讯：本质上是指通过`主内存的数据共享`。

### 1.4、Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before

**思路与手段**

- 扩容：水平扩容、垂直扩容
- 缓存：Redis、Memcache、GuavaCache等
- 队列：kafka、RabitMQ、RocketMQ等
- 应用拆分：服务化Dubbo和微服务Spring Cloud
- 限流：Guava RateLimiter使用、常用限流算法、自己实现分布式限流等
- 服务降级与服务熔断：服务降级的多重选择、Hystrix
- 数据库切库、分库分表：切库、分表、多数据源
- 高可用的一些手段：任务调度分布式elastic-job、主备curator的实现、监控报警机制

**CPU多级缓存：**缓存一致，乱序执行优化

**Java内存模型：**JMM规定，抽象结构，同步操作与规则

- lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态
- unlock（解锁）：作用于主内存变脸个，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
- use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
- assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量
- store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以遍随后的write的操作
- write（写入）：作用于主内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

#### JMM内存模型的同步规则

1. 如果要把一个变量从`主内存中复制到工作内存`，就需要按`顺序的执行read和load操作`，如果把变量从`工作内存中同步回主内存`，就需要按`顺序的执行store和write操作`。但java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
2. 不允许`read和load`、`store和write`操作之一`单独出现`。
3. 不允许一个线程`丢弃`它的最近assign的操作，即变量在工作内存中改变了之后`必须同步`到主内存中。
4. 不允许一个线程无原因的（没发生过任何assign操作）把数据从工作内存同步回主内存中。
5. 一个`新的变量只能在主内存中诞生`，不允许在工作内存中直接使用一个`未被初始化（load或assign）`的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。
6. 一个变量在`同一时刻只允许一条线程对其进行lock操作`，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。
7. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。
8. 如果一个变量实现没有被lock操作锁定，怎不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。
9. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

#### 有序性——happens-before原则

1. `程序次序规则`：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

   注：在单线程中，看起来是这样的，虚拟机可能会对代码进行指令重排序，虽然重排序了，但是运行结果在单线程中和指令书写顺序是一致的，事实上，这条规则是用来保证程序单在单线程中执行结果的正确性，无法保证程序在多线程中的正确性

2. `锁定规则`：一个unlock操作先行发生于后面对同一个锁的lock操作

3. `volatile变量规则`：对一个变量的写操作先行发生于后面对这个变量的读操作

4. `传递规则`：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

   前四条规则比较重要

5. `线程启动规则`：Thread对象的start()方法先行发生于次线程的每一个动作

6. `线程中断规则`：对线程interrupt()方法的调用先行发生于被中断线程的代码监测到中断事件的发生

7. `线程终结规则`：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行

8. `对象终结规则`：一个对象的初始化完成先行发生于他的finalize()方法的开始

### 1.5、线程安全是不是非真即假? 不是

`线程安全性不是一个非真即假的命题`。 Vector 的方法都是同步的，并且 Vector 明确地设计为在多线程环境中工作。但是它的线程安全性是有限制的，即在某些方法之间有状态依赖(类似地，如果在迭代过程中 Vector 被其他线程修改，那么由 Vector.iterator() 返回的 iterator会抛出ConcurrentModifiicationException)。

对于 Java 类中常见的`线程安全性级别`，没有一种分类系统可被广泛接受，不过重要的是在编写类时尽量记录下它们的线程安全行为。Bloch 给出了描述五类线程安全性的分类方法：`不可变`、`线程安全`、`有条件线程安全`、`线程兼容`和`线程对立`。只要明确地记录下线程安全特性，那么您是否使用这种系统都没关系。这种系统有其局限性 -- 各类之间的界线不是百分之百地明确，而且有些情况它没照顾到 -- 但是这套系统是一个很好的起点。这种分类系统的核心是调用者是否可以或者必须用外部同步包围操作(或者一系列操作)。下面几节分别描述了线程安全性的这五种类别。

- **不可变：**不可变的对象一定是线程安全的，并且永远也不需要额外的同步。因为一个不可变的对象只要构建正确，其外部可见状态永远也不会改变，永远也不会看到它处于不一致的状态。Java 类库中大多数基本数值类如 Integer 、 String 和 BigInteger 都是不可变的。\

  需要注意的是，对于Integer，该类不提供add方法，加法是使用+来直接操作。而+操作是不具线程安全的。这是提供原子操作类AtomicInteger的原。

- **线程安全：**线程安全的对象具有在上面“线程安全”一节中描述的属性 -- 由类的规格说明所规定的约束在对象被多个线程访问时仍然有效，不管运行时环境如何排线程都不需要任何额外的同步。这种线程安全性保证是很严格的 -- 许多类，如 Hashtable 或者 Vector 都不能满足这种严格的定义。

- **有条件的：**有条件的线程安全类对于单独的操作可以是线程安全的，但是某些操作序列可能需要外部同步。条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的迭代器 -- 由这些类返回的 fail-fast 迭代器假定在迭代器进行遍历的时候底层集合不会有变化。为了保证其他线程不会在遍历的时候改变集合，进行迭代的线程应该确保它是独占性地访问集合以实现遍历的完整性。通常，独占性的访问是由对锁的同步保证的 -- 并且类的文档应该说明是哪个锁(通常是对象的内部监视器(intrinsic monitor))。
  
  如果对一个有条件线程安全类进行记录，那么您应该不仅要记录它是有条件线程安全的，而且还要记录必须防止哪些操作序列的并发访问。用户可以合理地假设其他操作序列不需要任何额外的同步。
  
- **线程兼容：**线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用。这可能意味着用一个 synchronized 块包围每一个方法调用，或者创建一个包装器对象，其中每一个方法都是同步的(就像 Collections.synchronizedList() 一样)。也可能意味着用 synchronized 块包围某些操作序列。为了最大程度地利用线程兼容类，如果所有调用都使用同一个块，那么就不应该要求调用者对该块同步。这样做会使线程兼容的对象作为变量实例包含在其他线程安全的对象中，从而可以利用其所有者对象的同步。
  
  许多常见的类是线程兼容的，如集合类 ArrayList 和 HashMap 、 java.text.SimpleDateFormat 、或者 JDBC 类 Connection 和 ResultSet 。
  
- **线程对立：**线程对立类是那些不管是否调用了外部同步都不能在并发使用时安全地呈现的类。线程对立很少见，当类修改静态数据，而静态数据会影响在其他线程中执行的其他类的行为，这时通常会出现线程对立。线程对立类的一个例子是调用 System.setOut() 的类。

### 1.6、线程安全有哪些实现思路?

**思路：**

1. 给共享的资源加锁，保证每个资源变量每时每刻至多被一个线程占用。
2. 让线程也拥有资源，不用去共享进程中的资源。

**实现方案：**

1. 多实例或者多副本（ThreadLocal）：对于思路2，ThreadLocal可以为每个线程维护一个私有的本地变量
2. 使用锁机制（synchronize、lock方式）：为资源加锁
3. 使用java.util.concurrent下面的类库：有JDK提供的线程安全的集合类

### 1.7、如何理解并发和并行的区别?

**并发基本概念：**同时拥有两个或多个线程，如果程序在单核处理器上运行，多个线程将交替的换入或换出内存，这些线程是同时“存在”的，每个线程都处于执行过程中的某个状态。如果运行在多核处理器上，程序中的每个线程都将分配到一个处理器核上，因此可以同时运行。`多个线程操作相同的资源，保证线程安全，合理使用资源`

**高并发的概念：**高并发是互联网分布式系统架构设计中必须考虑的因素之一，通常是指，通过设计保证系统能够同时并行处理很多请求。`服务能同时处理很多请求，提高程序性能（更多的考虑技术手段）`。

### 1.8、线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?

#### 线程的状态

1. `初始（New）`：新创建一个线程对象，但还没有调用`start()`方法。
2. `运行（Runnable）`：将就绪（ready）和运行中（running）两种状态笼统的称为“运行”，线程对象创建后被其他线程（main线程）调用`start()`方法后，该线程位于可运行的线程池中，等待被线程调度选中，获取CPU的使用权，此时处于`就绪状态`。就绪状态的线程在获得CPU时间片后变为`运行中状态`。
3. `阻塞（BLOCKED）`：线程阻塞于锁。
4. `等待（Waiting）`：进入该状态的线程需要等待其他线程做出一些特定动作。（通知或中断）
5. `超时等待（Timed_Waiting）`：该状态不同于等待状态，可在指定的时间后自行返回。
6. `终止（Terminated）`：该线程已经执行完毕。

### 1.9、通常线程有哪几种使用方式?

创建线程的三种常见方式：1、继承Thread类；2、实现Runnable接口；3、实现Callable接口（jdk1.5>=）；4、线程方式创建

#### 采用实现Runnable、Callable接口的方式创建线程的优缺点

**优点：**线程类只是实现了Runnable或者Callable接口，还可以继承其他类。此时，多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想

**缺点：**编程稍微复杂，若需要访问当前线程必须使用`Thread.currentThread()`方法

#### 采用继承Thread类的方式创建线程的优缺点

**优点：**编写简单，可以直接使用`this`获取当前线程

**缺点：**丢失了类的扩展性，由于Java的单继承的机制，不能再继承其他父类

### 1.10、基础线程机制有哪些?

Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。

主要有三种 Executor：

- CachedThreadPool：一个任务创建一个线程；
- FixedThreadPool：所有任务只能使用固定大小的线程；
- SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。

#### Daemon

`守护线程`是程序运行时`在后台提供服务的线程`，不属于程序中不可或缺的部分。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。main() 属于非守护线程。在线程启动之前使用` setDaemon() `方法可以将一个线程设置为`守护线程`。

```
public static void main(String[] args) {
    Thread thread = new Thread(new MyRunnable());
    thread.setDaemon(true);
}
```

#### sleep()

Thread.sleep(millisec) 方法会`休眠当前正在执行的线程`，`millisec `单位为毫秒。`sleep() `可能会抛出 `InterruptedException`，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

```
public void run() {
    try {
        Thread.sleep(3000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

#### yield()

对静态方法` Thread.yield() `的调用声明了`当前线程已经完成了生命周期中最重要的部分`，`可以切换给其它线程来执行`。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。

```
public void run() {
    Thread.yield();
}
```

### 1.11、线程的中断方式有哪些?

中断（Interrupt）一个线程意味着在该线程完成任务之前`停止其正在进行的一切`，`有效地中止其当前的操作`。线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序。

`Thread.interrupt()`方法: 作用`是中断线程`。将会设置该线程的中断状态位，即设置为true，中断的结果线程是死亡、还是等待新的任务或是继续运行至下一步，就取决于这个程序本身。线程会不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。它并不像stop方法那样会中断一个正在运行的线程。

interrupt()方法`只是改变中断状态`，`不会中断一个正在运行的线程`。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出interruptedException的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。这一方法实际完成的是，给受阻塞的线程发出一个中断信号，这样受阻线程检查到中断标识，就得以退出阻塞的状态。

更确切的说，如果线程被`Object.wait`, `Thread.join`和`Thread.sleep`三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个 InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用 interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出 InterruptedException。

- 使用 interrupt() + isInterrupted()来中断线程　　

### 1.12、线程的互斥同步方式有哪些? 如何比较和选择?

### 1.13、线程之间有哪些协作方式?

### 1.14、如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，也就是当run()方法运行完之后线程终止。
2. 使用stop方法强行终止，但是不推荐使用。因为stop、suspend和resume一样都是过期作废的方法。
3. 使用interrupt方法中断线程

```java
class MyThread extends Thread {
    volatile boolean stop = false;
    public void run() {
        while (!stop) {
            System.out.println(getName() + " is running");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("week up from blcok...");
                stop = true; // 在异常处理代码中修改共享变量的状态
            }
        }
        System.out.println(getName() + " is exiting...");
    }
}
class InterruptThreadDemo3 {
    public static void main(String[] args) throws InterruptedException {
        MyThread m1 = new MyThread();
        System.out.println("Starting thread...");
        m1.start();
        Thread.sleep(3000);
        System.out.println("Interrupt thread...: " + m1.getName());
        m1.stop = true; // 设置共享变量为true
        m1.interrupt(); // 阻塞时退出阻塞状态
        Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况
        System.out.println("Stopping application...");
    }
}
```

### 1.15、notify()和notifyAll()的区别？

- notify()可能会导致`死锁`，而notifyAll()不会。
- 任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行`synchronized`中的代码。使用`notifyAll()`可以唤醒`所有处于wait状态的线程`，使其重新进入锁的争夺队列中，而`notify()只能唤醒一个`。
- wait()应配合while循环使用，不应该使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续使用wait()直至条件满足再往下执行。
- notify()是对notifyAll()的一个优化，但必须要有精确的应用场景，并且要求正确使用，否则会导致死锁。正确的场景应该是WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中。

### 1.16、sleep()和wait()有什么区别？

- sleep()方法是属于Thread类中的，而wait()是属于Object类中的。
- sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。
- 调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。

### 1.17、Thread类中的start()和run()方法有什么区别？

start()方法是用来`启动新创建的线程`，且start()内部调用了run()方法，和直接调用run()方法的效果是不一样的。调用run()方法的时候，只会是在`原来的线程中调用`，没有新的线程启动，start()方法才会启动新线程。

### 1.18、为什么wait、notify和notifyAll这些方法不在thread类里面？

是因为Java提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。由于`wait、notify、notifyAll`都是锁级别的操作，所以把它们定义在Object类中，因为锁属于对象。

### 1.19、为什么wait和notify方法要在同步块中调用？

1. 只有在`调用线程拥有某个对象的独占锁`时，才能够调用该对象的wait()、notify()和notifyAll()方法。
2. 如果不这么做，代码会抛出IllegalMonitorStateException异常。
3. 为了避免wait和notify之间产生竞态条件。

wait()方法强制当前线程释放对象锁。意味着在调用某对象的wait()之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。

在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()对象。

调用wait()方法的原因通常是，调用线程希望某个特殊的状态（或变量）被设置之后再继续执行。调用notify()或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程。特殊状态已经被设置，这个状态作为线程间通信的通道，它必须是一个可变的共享状态（或变量）。

### 1.20、Java中interrupted和isInterrupted方法的区别？

interrupted()和isInterrupted()的主要区别是`前者会将中断状态清除而后者不会`。Java多线程的中断机制是用`内部标识`来实现的，调用`Thread.interrupt()`来中断一个线程就会设置`中断标识为true`。当中断线程调用静态方法`Thread.interrupted()`来`检查中断状态`时，`中断状态会被清零`。而`非静态方法isInterrupted()`用来`查询其他线程的中断状态`且不会改变中断状态标识。简单的说就是任何抛出`InterruptedException`异常的方法都会将`中断状态清零`。无论如何，`一个线程的中断状态有可能被其他线程调用中断来改变`。

### 1.21、Thread类中的yield方法有什么作用？

`yield()`方法可以`暂停当前正在执行的线程对象`，让其他有相同优先级的线程执行。它是一个静态方法，而且只保证当前线程放弃CPU占用而不能保证使其他线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。

### 1.22、线程池中submit()和execute()方法有什么区别？

两个方法都可以向`线程池提交任务`，`execute()方法的返回类型是void`，定义在`Executor接口`中。而`submit()方法可以返回持有计算结果的Future对象`，定义在`ExecutorService`接口中，扩展了Executor接口，其他线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。

### 1.23、说说进程和线程的区别？

- 进程是一个执行中的程序，是系统进行资源分配和调度的一个独立单位。
- 线程是进程的一个实体，一个进程可以拥有多个线程，线程之间共享地址空间和其他资源（所以通信和同步等操作线程比进程更容易）
- 线程的上下文切换比进程上下文切换要快很多。
- 进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。
- 线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。

### 1.24、线程之间是如何进行通信的？

线程之间的通信方式有两种：`共享内存`和`消息传递`

**共享内存**

在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。

1. 线程A把本地内存A更新过的共享变量刷新到主内存中去。
2. 线程B到主内存中去读取线程A之前更新过的共享变量。

**消息传递**

在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在Java中典型的消息传递方式，就是`wait()和notify()，或者BlockingQueue`。

### 1.25、CAS的原理呢？

CAS叫做CompareAndSwap，比较并交换，主要是通过处理器的指令来保证操作的原子性，包含三个操作数：

1. 变量内存地址，V表示
2. 旧的预期值，A表示
3. 准备设置的新值，B表示

当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。

### 1.26、CAS有什么缺点吗？

CAS的缺点主要有3点：

1. ABA问题：该问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终结果。

   Java中有AtomicStampedReference来解决这个问题，它加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。

2. 循环时间长开销大：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。

3. 只能保证一个共享变量的原子操作：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。

### 1.27、说说ThreadLocal原理？

`ThreadLocal`可以理解为`线程本地变量`，他会在每个线程都创建一个副本，在线程之间访问`内部副本变量`就行了，做到了线程之间互相隔离，相比于synchronized的做法是用`空间换时间`。

ThreadLocal有一个`静态内部类ThreadLocalMap`，ThreadLocalMap又包含了一个`Entry数组`，Entry本身是一个`弱引用`，他的key是指向ThreadLocal的弱引用，Entry具备了保证` key value `键值对的能力。

`弱引用`的目的是为了`防止内存泄露`，如果是`强引用`那么ThreadLocal对象除非`线程结束否则始终无法被回收`，`弱引用则会在下一次GC的时候被回收`。但是这样还是会存在内存泄露的问题，假如key和ThreadLocal对象被回收之后，entry中就存在key为null，但是value有值的entry对象，是永远没办法被访问到的，除非线程结束运行。

但是只要ThreadLocal使用恰当，在使用完之后调用` remove() `方法删除Entry对象，实际上是不会出现这个问题的。

![image-20220720195206532](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207201952095.png)

#### 为什么使用弱引用？

1. 如果`使用强引用`：ThreadLocalMap的`生命周期基本和Thread的生命周期一样`，当前线程如果没有终止，那么ThreadLocalMap始终不会被GC回收，而ThreadLocalMap持有对ThreadLocal的强引用，那么ThreadLocal也不会被回收，当线程生命周期长，如果没有手动删除，则会造成kv累积，从而导致OOM。
2. 如果`使用弱引用`：弱引用中的对象`具有很短的生命周期`，在系统GC的时候，只要发现弱引用，不管堆空间是否足够，都会将对象进行回收。而当ThreadLocal的强引用被回收时，ThreadLocalMap所持有的弱引用也会被回收，如果没有手动删除kv，也会造成value累积，导致OOM。

使用`弱引用`至少可以保证不会因为`map的key累积从而导致OOM`，而对应的value可以通过remove，get，set方法在下一次调用时被清除。可见，内存泄露的根源`不是弱引用`，而是`ThreadLocalMap的生命周期和Thread一样长`，造成累积导致的。

### 1.28、什么是阻塞队列？阻塞队列实现的原理是什么？如何使用阻塞队列来实现生产者-消费者模型？

阻塞队列是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。

阻塞队列常用用生产者和消费者的场景，生产者是往队列里添加元素的线程，消费则是从队列里拿元素的线程。阻塞队列就生产者存放元素的容器，而消费者也只从容器里拿元素。

JDK7提供了7个阻塞队列。分别是：

- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。
- PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
- DelayQueue：一个使用优先级队列实现的无界阻塞队列。
- SynchronousQueue：一个不存储元素的阻塞队列。
- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

Java 5之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好，wait ,notify,notifyAll,sychronized这些关键字。而在java 5之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。

BlockingQueue接口是Queue的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性，当生产者线程试图向BlockingQueue放入元素时，如果队列已满，则线程被阻塞，当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞，正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中放入元素，取出元素，它可以很好的控制线程之间的通信。

阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。

### 1.29、什么是多线程的上下文切换？

在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。

在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。

上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。

### 1.30、什么是Daemon线程？它有什么意义？

所谓后台(daemon)线程，也叫守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这个线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说， 只要有任何非后台线程还在运行，程序就不会终止。

必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。注意：后台进程在不执行fifinally子句的情况下就会终止其run()方法。

比如：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。

### 1.31、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。

在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

**乐观锁的实现方式：**

1、使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。2、java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。

CAS缺点：

1. ABA问题：比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。

2. 循环时间长开销大：对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。 

3. 只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。

## 二、Synchronized面试题

### 2.1、Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。

- 修饰代码块：被修饰的代码块称为同步代码块，作用范围是大括号{}括起来的代码
- 修饰方法：被修饰的方法称为同步方法，作用范围是整个方法
- 修饰静态方法：作用范围是整个静态方法
- 修饰类：作用范围是synchronized后面括号括起来的部分。

### 2.2、Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。

**通过锁的角度：**`内置锁`，万物皆对象，Java中每一个对象都可以用作同步的锁，这些锁就称之为内置锁。修饰`普通方法`的时候，内置锁就是当前类的实例；修饰`静态方法`的时候，内置锁是当前的Class字节码对象。synchronized的原理就是加了锁，由内置锁和互斥锁决定的。每个`synchronized`对象都有锁，并且这些锁都是`互斥`的，确保了一个时刻只能访问一个线程，由此保证了`线程的安全性`。

**内存模型角度：**JMM内存模型规定了，所有的变量都存储在`主内存中`（主内存指虚拟内存中的一部分），并且每条线程都会有自己的`工作内存`（类比CPU中的寄存器和高速缓存），线程的`工作内存中保存了该线程使用到的变量的主内存的副本拷贝`，且线程对变量的所有操作都必须在`工作内存中继续`，而`不能直接读写主内存中的变量`。不同线程之间也无法直接访问对方的工作内存中的变量，线程之间变量值的传递都需要通过主内存完成。

在使用`synchronized`进行同步的时候，真正被同步的是在工作线程中的数据。就是在同步块或同步方法执行完后，对`被锁定的对象做的任何修改要在释放锁之前回写到主内存中`；在进入同步块得到锁之后，`被锁定对象的数据是从主内存中读取出来的`，持有锁的线程的工作内存中的数据副本一定和主内存中的数据视图是同步的。

### 2.3、Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。

**Synchronized的缺陷：**

- 效率低：锁的释放情况少，只有在代码执行完毕或异常结束之后才会释放锁。且试图获取锁的时候不能设定超时条件，不能中断一个正在使用锁的线程。
- 不够灵活：加锁和释放锁的时机单一，每个锁仅有单一的条件（某个对象），相对而言，读写锁更加灵活
- 无法知道是否成功获取锁

**Lock的操作：**

- `lock()`：加锁
- `unlock()`：释放锁
- `tryLock()`: 尝试获取锁，返回一个boolean值
- `tryLock(long,TimeUtil)`: 尝试获取锁，可以设置超时

多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。`ReentrantLock`的`lockInterruptibly()`方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后`ReentrantLock`响应这个中断，不再让这个线程继续等待。有了这个机制，使用`ReentrantLock`时就不会像`synchronized`那样产生死锁了。

### 2.4、Synchronized和Lock的对比，和选择?

1. Lock是`接口`，Synchronized是`关键字`
2. Synchronized可以`锁对象`、`锁方法`、`锁代码块`，Lock只能`锁代码块`
3. Synchronized锁`不需要主动释放`，Lock需要在`finally中主动释放`
4. Synchronized的`锁可重入、不可中断、非公平`，而Lock锁`可重入、可判断、可公平（两者皆可）`
5. Synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁

**synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。**独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。

**而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作**（Compare and Swap）。我们可以进一步研究ReentrantLock的源代码，会发现其中比较重要的获得锁的一个方法是compareAndSetState。这里其实就是调用的CPU提供的特殊指令。

- 底层实现上，syc是jvm层面的锁，是java关键字，通过moniter对象完成，对象只有在同步块和同步方法中的才能调用wait/notify方法，syc的实现涉及锁的升级。 lock接口层面得锁，利用CAS自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。
- 是否要手动释放，synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致死锁现象。一般通过lock()和unlock()方法配合try/finally语句块来完成，使用释放更加灵活。
- 是否可中断， synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。
- 是否公平锁，synchronized为非公平锁 ，ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁。
- 锁是否可以绑定条件Condition, synchronized不能绑定； ReentrantLock通过绑定Condition结合await()/singal()方法实现线程的精确唤醒，而不是像synchronized通过Object类的wait()/notify()/notifyAll()方法要么随机唤醒一个线程要么唤醒全部线程。
- 锁的对象，synchronzied锁的是对象，锁是保存在对象头里面的，根据对象头数据来标识是否有线程获得锁/争抢锁；ReentrantLock锁的是线程，根据进入的线程和int类型的state标识锁的获得/争抢。

### 2.5、Synchronized在使用时有何注意事项?

1. **synchronized关键字不能继承**

   虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。

2. 在定义接口方法时不能使用synchronized关键字。

3. 构造方法不能使用synchronized关键字

4. synchronized锁不能被中断

5. synchronized锁可重入

6. synchronized锁不带超时功能

   ReentrantLock的trylock是具备带超时功能的，在指定时间没获取到锁，线程就会苏醒，有助于预防死锁

7. 唤醒/等待需要synchronized锁

8. 使用synchronized锁时尽量缩小范围以保证性能

### 2.6、Synchronized修饰的方法在抛出异常时,会释放锁吗?

一个代码被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程只能一致等待，等待获取锁的线程释放锁，且这里持有锁的线程释放锁只会有两种情况：

- 获取锁的线程执行完了该代码块，然后线程释放对锁的占有
- 线程执行发生异常，此时JVM会让线程自动释放锁。

### 2.7、多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?

### 2.8、Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?

### 2.9、我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?

### 2.10、什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?

### 2.11、不同的JDK中对Synchronized有何优化?

### 2.12、Synchronized和ReentrantLock有什么不同？

**相似点：**

这两种同步方式有许多相似之处，都加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的。

**区别：**

这两种方式的最大区别是对于Synchronized来说，它是Java的关键字，是原生语法层面的互斥，需要JVM实现。而ReentrantLock它是JDK1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来实现。

Synchronized经过编译，会在同步块的前后分别形成monitor enter和monitor exit这两个字节码指令。在执行monitor enter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitor exit指令时会将锁计算器减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。

由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能：

- 等待可中断：持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。
- 公平锁：多个线等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。
- 锁绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象。

### 2.13、有三个线程T1、T2、T3如何保证顺序执行？

在多线程中有多种方法让线程按特定顺序来执行，可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序应该先启动最后一个（T3调用T2，T2调用T1）。

实际上启动三个线程中哪一个都行，因为在每个线程的run方法中用join方法限定了三个线程的执行顺序。

### 2.14、SynchronizedMap和ConcurrentHashMap有什么区别？

SynchronizedMap()和Hashtable一样，实际上在调用map所有方法时，都对整个map进行同步。而ConcurrentHashMap的实现更加精细，它对map中的所有桶都加了锁。所以，只要有一个线程访问map，其他线程就无法进入map，而如果一个线程在访问ConcurrentHashMap某个桶时，其他线程，仍然可以对map执行某些操作。

所以，ConcurrentHashMap在性能以及安全性方面，明显比Collections.synchronizedMap()更加有优势。同时，同步操作精确控制到桶，这样，即使在遍历map时，如果其他线程试图对map进行数据修改，也不会抛出ConcurrentModificationException。

### 2.15、说说对于Synchronized关键字的了解？

`synchronized`关键字解决的是`多个线程之间访问资源的同步性`，且可以保证被它修饰的方法或者代码块在`任意时刻只能有一个线程执行`。

另外，在Java早期版本中，`synchronized属于重量级锁`，`效率低下`，因为监视器（monitor）是依赖于底层的`操作系统的Mutex Lock`来实现的，Java的线程映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是早期的synchronized的效率低下的原因。

在Java6之后，Java官方对从JVM层面对synchronized较大优化，JDK1.6对锁的实现引入了大量的优化，如`自旋锁`、`适应性自旋锁`、`锁消除`、`锁粗化`、`偏向锁`、`轻量级锁`等技术来减少锁操作的开销。

### 2.16、说说怎么使用Synchronized关键字？

- `修饰实例方法：`作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。
- `修饰静态方法：`给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（static表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态synchronized方法，而线程B需要调用这个实例对象所属类的静态synchronized方法，是允许的，不会发生互斥现象。因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前实例对象锁。
- `修饰代码块：`指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

synchronized关键字加到static静态方法和synchronized(class)代码块上都是给Class类上锁。synchronized关键字加到实例方法上是给对象实例上锁。尽量不要使用synchronized(String a)，因为JVM中，字符串常量池具有缓存功能。

## 三、volatile面试题

### 3.1、volatile是什么？可以保证有序性吗？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，将具备两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这值对其他线程来说是立即可见的。volatile关键字会强制将修改的值立即写入主存中。
2. 禁止指令重排集

volatile不是原子性操作。

#### 什么叫保证部分有序性？

当程序执行到volatile变量的读操作或写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

```java
x = 2; //语句1
y = 0; //语句2
flag = true; //语句3
x = 4; //语句4
y = -1; //语句5
```

由于flag变量为volatile变量，在进行指令重排序的过程的时候，不会改变语句3与其他的语句的顺序。但不是不能保证其他语句的顺序。

使用volatile一般用于状态标记量和单例模式的双检锁。

### 3.2、volatile关键字的作用是什么?

- 保证可见性：在JMM（java memory model）java内存模型中，其他线程`从主内存空间把值拷贝到自己的工作空间，线程修改之后的值会返回给主内存`，主内存会通知其他线程，此为可见性。
- 防止指令重排：CPU为了执行效率会并发执行操作指令，volatile可以使指令一个一个的执行。
- 不保证原子性



- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
- 禁止进行指令重排序
- volatile本质是在告诉JVM当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法和类级别的。
- volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改可见性和原子性。
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

### 3.3、volatile能保证原子性吗?

- 不能保证原子性
- volatile不能保证完全的原子性，只能保证单次的读/写操作具有原子性。先从如下两个问题来理解（后文再从内存屏障的角度理解）

**如何解决原子性**

1. 通过synchronized关键字。
2. 通过使用AtomicXX，不加锁,采用[CAS](https://so.csdn.net/so/search?q=CAS&spm=1001.2101.3001.7020)（compareAndSet）解决。其本质是使用UnSafe本地方法（CPU原语）。
3. 使用LongAdder:最快（在线程多的情况下，使用分段锁）

### 3.4、之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?

### 3.5、i++为什么不能保证原子性?

i++操作是分为读写两个步骤的，当一个线程的`读操作被阻塞时`，另一个线程也执行i++操作。但是此时第一个线程由于被阻塞并没有执行写操作，在主存中的变量的值仍是之前的数据。两个线程执行i++操作完成后，i变量可能只增加了1。因此`i++无法保证原子性`。

### 3.6、volatile是如何实现可见性的?  内存屏障。

volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现

- 内存屏障，又称内存栅栏，是一个 CPU 指令。
- 在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止+ 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。

为了`提高处理速度`，处理器不直接和内存（主存）进行通信，而是先将系统内存的数据读到`内部缓存(L1，L2 或其他)`后再进行操作，但`操作完不知道何时会写到内存`。如果对声明了 volatile 的变量进行写操作，JVM 就会向处理器发送一条` lock 前缀的指令`，将这个变量所在缓存行的数据写回到系统内存。为了保证各个处理器的缓存是一致的，实现了`缓存一致性协议(MESI)`，每个处理器通过`嗅探在总线上传播的数据`来`检查自己缓存的值是不是过期了`，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的`缓存行设置成无效状态`，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。所有多核处理器下还会完成：当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。

被volatile修饰的变量被修改时，会将修改后的变量直接写入主存中，并且将其他线程中该变量的`缓存置为无效`，从而让其它线程对该变量的引用`直接从主存中获取数据`，这样就保证了变量的可见性。

### 3.7、volatile是如何实现有序性的?  happens-before等

### volatile 的 happens-before 关系

happens-before 规则中有一条是 volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。

```java
//假设线程A执行writer方法，线程B执行reader方法
class VolatileExample {
    int a = 0;
    volatile boolean flag = false;
    
    public void writer() {
        a = 1;              // 1 线程A修改共享变量
        flag = true;        // 2 线程A写volatile变量
    } 
    
    public void reader() {
        if (flag) {         // 3 线程B读同一个volatile变量
        int i = a;          // 4 线程B读共享变量
        ……
        }
    }
}
```

根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。

- 根据程序次序规则：1 happens-before 2 且 3 happens-before 4。
- 根据 volatile 规则：2 happens-before 3。
- 根据 happens-before 的传递性规则：1 happens-before 4。

![image-20220718112011932](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207181120925.png)



### 3.8、说下volatile的应用场景?

- 变量的修改不依赖于变量本身
  像是i++、i+=这类的操作在多线程下都是不能保证变量的原子性的。
- 该变量没有包含在具有其他变量的不变式中
- 对变量的写操作不依赖于当前值。
- 该变量没有包含在具有其他变量的不变式中。
- 只有在状态真正独立于程序内其他内容时才能使用 volatile

### 3.9、volatile的底层原理？

被volatile修饰的变量被修改时，会将修改后的变量直接写入主存中，并且将其他线程中该变量的`缓存置为无效`，从而让其它线程对该变量的引用`直接从主存中获取数据`，这样就保证了变量的可见性。
但是volatile修饰的变量在`自增`时由于该操作分为读写两个步骤，当一个线程的`读操作被阻塞时`，另一个线程同时也进行了`自增操作`，此时由于第一个线程的写操作没有进行，所以主存中仍旧是之前的原数据。当两个线程自增完成后，该变量可能只加了1。因而`volatile是无法保证对变量的任何操作都是原子性的。`

## 四、线程池

### 4.1、常用的线程池有哪些？

- newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。
- newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。
- newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。
- newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。

### 4.2、说说对线程池的理解？

线程池如何用、线程池的好处、线程池的启动策略

**什么是线程池**

`线程池`其实就是一种`多线程处理形式`，处理过程中可以将`任务添加到队列中`，然后在创建线程后自动启动这些任务。任务就是`实现了Runnable或Callable接口的实例对象`。线程池是计算机开发中的一种池化技术，是为了提高资源的利用率，将一些资源重复利用，避免重复的构建来提高效率。

**核心线程数**

在线程池初始化时，会指定创建核心线程的数量，有任务提交给线程池时，先判断是否有空闲线程，如果有空闲线程，则直接使用，如果没有则看当前线程池中的数量是不是小于核心线程数，如果是则创建新的线程，如果已达到核心线程数，则需要做下一步操作。

**线程池的三个好处**

1. 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行资源的统一分配、调优和监控。

### 4.3、线程池核心线程数怎么设置呢？

分为CPU密集型和IO密集型

**CPU密集型**

这种任务消耗的主要是CPU资源，可以将线程数设置为N（CPU核心数）+1，比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断，或则其他原因导致的任务暂停而带来的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间。

**IO密集型**

系统会应用大部分的时间来处理I/O交互，而线程在处理I/O的时间段内不会占用CPU来处理，这时就可以将CPU交给其他线程来处理。因此在I/O密集型任务的应用中，可以多配置一些线程，具体的计算方法是：核心线程数=CPU核心数量*2。

### 4.4、线程池中队列常用类型有哪些？

- `ArrayBlockingQueue （有界队列）`是一个基于`数组结构`的**有界阻塞队列**，此队列按 `FIFO（先进先出）原则`对元素进行排序。
- `LinkedBlockingQueue （无界队列）`一个基于`链表结构`的**阻塞队列**，此队列按`FIFO （先进先出） `排序元素，吞吐量通常要高于 `ArrayBlockingQueue `。
- `SynchronousQueue （直接提交队列）`一个不存储元素的**阻塞队列**。
- `PriorityBlockingQueue `一个具有优先级的**无限阻塞队列**。 PriorityBlockingQueue 也是**基于最小二叉堆实现**。
- `DelayQueue`只有当其指定的延迟时间到了，才能够从队列中获取到该元素。
- `DelayQueue `是一个没有大小限制的队列，
- 因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。

### 4.5、线程池原理知道吗？核心参数有哪些？

线程池的核心参数：

1. `最大线程数`：maximumPoolSize
2. `核心线程数`：corePoolSize
3. `活跃时间`：keepAliveTime
4. `阻塞队列`：workQueue
5. `拒绝策略`：RejectedExecutionHandler

当提交一个新任务到线程池时，具体的执行流程如下：

1. 当我们提交任务，线程池会根据corePoolSize大小创建若干任务数量线程执行任务。
2. 当任务的数量超过了corePoolSize数量，后续的任务将会进入阻塞队列阻塞排队。
3. 当阻塞队列也满了之后，那么将会继续创建（maximumPoolSize-corePoolSize）个数量的线程来执行任务，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程等待keepAliveTime之后被自动销毁。
4. 如果达到maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理

![image-20220720201555365](https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207202015703.png)

### 4.6、线程池的拒绝策略？

主要有4种拒绝策略

1. AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
2. CallerRunsPolicy：只用调用者所在的线程来处理任务
3. DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务，也不抛出异常

## 五、锁相关知识

### 5.1、锁的优化机制了解吗？

从JDK1.6之后，synchronized本身也在不断优化锁的机制，有些情况下它并不会是一个很重量级的锁。优化机制包括自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。

锁的状态从低到高依次为`无锁` -> `偏向锁` -> `轻量级锁` -> `重量级锁`

- `自旋锁`：由于大部分时候，锁被占用的时间很短，共享变量的锁定时间也很短，所以没必要挂起线程，用户态和内核态的来回上下文切换会严重影响性能。自旋的概念就是让线程执行一个忙循环（啥也不干），防止用户态转为内核态，自旋锁可以通过设置-XX:+UseSpining来开启，自旋的默认次数是10次，可以使用-XX:PreBlockSpin设置。
- 自适应锁：自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是前一次在同一个锁上的自旋时间和锁的持有者状态来决定的。
- 锁消除：锁消除指的是JVM检测到一些同步的代码块，完全不存在数据竞争的场景，也就是不需要进行加锁，就会进行锁消除。
- 锁粗化：锁粗化指的是有很多操作都是对同一个对象进行加锁，就会把锁的同步范围扩展到整个操作序列之外。
- 偏向锁：当线程访问同步块获取锁的时候，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，之后这个线程再次进入同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第一个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进行同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。
- 轻量级锁：JVM的对象的对象头中包含有一些锁的标志位，代码进入同步块的时候，JVM将会使用CAS方式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试自旋来获得锁。

### 5.2、产生死锁的必要条件？

死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。

- 互斥条件：一个资源每次只能被一个线程使用。
- 请求与保持条件：一个线程因请求资源而被阻塞，对已获得的资源保持不放。
- 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺。
- 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

### 5.3、解决死锁的基本方法有哪些？

**预防死锁：**

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请求保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其他资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）/
