# 线程相关面试题

## 一、线程基础

### 1.1、多线程的出现是要解决什么问题的?

- **发挥多核CPU的优势**

  多线程，可以真正发挥多核CPU的优势来，达到充分利用CPU的目的，采用多线程的方式去同时完成几件事情而不互相干扰。

- **防止阻塞**

  从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，降低程序整体的效率。但是单核CPU还是要应用多线程，就是为了防止阻塞。（假如单核CPU使用单线程，只要这个线程阻塞了，比如说远程读取某个数据，对端迟迟未返回又没有设置超时时间，此时整个程序在数据返回回来之前就停止运行了）

  多线程有效的防止这个问题，多条线程同时运行，就算一条线程的代码执行读取数据阻塞了，也不会影响其它任务的执行。

- **便于建模**

  假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。如果将这个大的任务分解成几个小任务，多个任务分别建立程序模型，并通过多线程运行，那就简单挺多。

### 1.2、线程不安全是指什么? 举例说明

- 线程安全：指多个线程在执行同一段代码的时候采用锁机制，使每次执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。
- 线程不安全：指不提供锁机制，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。
- 举例：例如售票系统，有票100张，在多线程情况下，用户A和用户B都来买票，如果多线程没有采用锁机制，就会线程不安全，出现100-1同时执行的情况，最终A和B买完票后剩下99张票，而不是98张。
- 引起线程不安全的原因：线程安全问题是由全局变量及静态变量引起的；如果每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，此时就需要考虑线程同步的问题，否则可能会影响线程安全。

### 1.3、并发出现线程不安全的本质什么? 可见性，原子性和有序性。

多线程并发时会不安全，多线程同时操作对象的属性或者状态时，会因为线程之间的信息不同步，A线程读取到的状态已经过时，而A线程并不知道，导致产生线程不安全。所以并发时出现线程不安全的本质是**线程之间的信息不同步**。

**可见性：**在多线程中，若线程A中进行的每一步都可以被线程B观测到，则称线程A对线程B具有可见性；线程B不仅可以看到线程A处理的结果，还能准确的知道在处理过程中，每一个状态的改变，已经状态改变的顺序。Java线程的通讯是透明的，线程之间不可以直接进行信息交换，所有的信息必须同内存共享。因此多线程是天然不可见的。也就是在不主动干涉的情况下，线程之间是不可见的。

**有序性：**在java中，单线程总是顺序执行的。当编译器和处理器重排序时，必须保证，不管怎么重排序，单线程的执行结果不能被改变。

**原子性：**一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么都不执行。

### 1.4、Java是怎么解决并发问题的? 3个关键字，JMM和8个Happens-Before

### 1.5、线程安全是不是非真即假? 不是

### 1.6、线程安全有哪些实现思路?

### 1.7、如何理解并发和并行的区别?

### 1.8、线程有哪几种状态? 分别说明从一种状态到另一种状态转变有哪些方式?

### 1.9、通常线程有哪几种使用方式?

创建线程的三种常见方式：1、继承Thread类；2、实现Runnable接口；3、实现Callable接口（jdk1.5>=）；4、线程方式创建

#### 采用实现Runnable、Callable接口的方式创建线程的优缺点

**优点：**线程类只是实现了Runnable或者Callable接口，还可以继承其他类。此时，多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好的体现了面向对象的思想

**缺点：**编程稍微复杂，若需要访问当前线程必须使用`Thread.currentThread()`方法

#### 采用继承Thread类的方式创建线程的优缺点

**优点：**编写简单，可以直接使用`this`获取当前线程

**缺点：**丢失了类的扩展性，由于Java的单继承的机制，不能再继承其他父类

### 1.10、基础线程机制有哪些?

### 1.11、线程的中断方式有哪些?

### 1.12、线程的互斥同步方式有哪些? 如何比较和选择?

### 1.13、线程之间有哪些协作方式?

### 1.14、如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，也就是当run()方法运行完之后线程终止。
2. 使用stop方法强行终止，但是不推荐使用。因为stop、suspend和resume一样都是过期作废的方法。
3. 使用interrupt方法中断线程

```java
class MyThread extends Thread {
    volatile boolean stop = false;
    public void run() {
        while (!stop) {
            System.out.println(getName() + " is running");
            try {
                sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("week up from blcok...");
                stop = true; // 在异常处理代码中修改共享变量的状态
            }
        }
        System.out.println(getName() + " is exiting...");
    }
}
class InterruptThreadDemo3 {
    public static void main(String[] args) throws InterruptedException {
        MyThread m1 = new MyThread();
        System.out.println("Starting thread...");
        m1.start();
        Thread.sleep(3000);
        System.out.println("Interrupt thread...: " + m1.getName());
        m1.stop = true; // 设置共享变量为true
        m1.interrupt(); // 阻塞时退出阻塞状态
        Thread.sleep(3000); // 主线程休眠3秒以便观察线程m1的中断情况
        System.out.println("Stopping application...");
    }
}
```

### 1.15、notify()和notifyAll()的区别？

- notify()可能会导致死锁，而notifyAll()不会
- 任何时候只有一个线程可以获得锁，也就是说只有一个线程可以运行`synchronized`中的代码。使用`notifyAll()`可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify()只能唤醒一个。
- wait()应配合while循环使用，不应该使用if，务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续使用wait()直至条件满足再往下执行。
- notify()是对notifyAll()的一个优化，但必须要有精确的应用场景，并且要求正确使用，否则会导致死锁。正确的场景应该是WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify()下一个线程，并且自身需要重新回到WaitSet中。

### 1.16、sleep()和wait()有什么区别？

- sleep()方法是属于Thread类中的，而wait()是属于Object类中的。
- sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是它的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。在调用sleep()方法的过程中，线程不会释放对象锁。
- 调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池只有针对此对象调用notify()方法后本线程才进入对象锁定池准备，获取对象锁进入运行状态。

## 二、Synchronized面试题

- Synchronized可以作用在哪里? 分别通过对象锁和类锁进行举例。
- Synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。
- Synchronized由什么样的缺陷?  Java Lock是怎么弥补这些缺陷的。
- Synchronized和Lock的对比，和选择?
- Synchronized在使用时有何注意事项?
- Synchronized修饰的方法在抛出异常时,会释放锁吗?
- 多个线程等待同一个snchronized锁的时候，JVM如何选择下一个获取锁的线程?
- Synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?
- 我想更加灵活的控制锁的释放和获取(现在释放锁和获取锁的时机都被规定死了)，怎么办?
- 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?
- 不同的JDK中对Synchronized有何优化?

## 三、volatile面试题

### 3.1、volatile是什么？可以保证有序性吗？

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，将具备两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这值对其他线程来说是立即可见的。volatile关键字会强制将修改的值立即写入主存中。
2. 禁止指令重排集

volatile不是原子性操作。

#### 什么叫保证部分有序性？

当程序执行到volatile变量的读操作或写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

```java
x = 2; //语句1
y = 0; //语句2
flag = true; //语句3
x = 4; //语句4
y = -1; //语句5
```

由于flag变量为volatile变量，在进行指令重排序的过程的时候，不会改变语句3与其他的语句的顺序。但不是不能保证其他语句的顺序。

使用volatile一般用于状态标记量和单例模式的双检锁。

- volatile关键字的作用是什么?
- volatile能保证原子性吗?
- 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?
- i++为什么不能保证原子性?
- volatile是如何实现可见性的?  内存屏障。
- volatile是如何实现有序性的?  happens-before等
- 说下volatile的应用场景?
