# 多线程与并发

## 一、线程基础

### 1.1、什么是进程和线程

**进程是程序运行资源分配的最小单位**

- 进程是系统进行资源分配和调度的基本单位，是操作系统结构的基础。其中资源包括：CPU、内存空间、磁盘IO等，同一进程中的**多条线程共享该进程中的全部系统资源**，而进程和进程之间是相互独立的，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，也是系统进行资源分配和调度的一个独立单位。
- 进程是程序在计算机上的一次执行活动。当你运行一个程序后，你就启动了一个进程。显然，程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。

**线程是CPU调度的最小单位，必须依赖于进程而存在**

- 线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

**线程无处不在**

- 任何一个程序都必须要创建线程，特别是Java不管任何程序都必须启动一个main函数的主线程。Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制，远程访问接口RM等。任何一个监听事件，onclick的触发事件等都离不开线程和并发的知识。

### 1.2 、CPU核心是和线程数的关系

  多核心：也指单芯片多处理器( Chip Multiprocessors，简称CMP)，CMP是由美国斯坦福大学提出的，其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内，各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向，称为并行处理。

  多线程：Simultaneous Multithreading，简称SMT，让同一个处理器上的多个线程同步执行并共享处理器的执行资源。

  核心数、线程数:目前主流CPU都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系。

### 1.3、CPU时间片轮转机制

  时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。

  上下文切换 (context switch)，其实际含义是任务切换，或者CPU寄存器切换。当多任务内核决定运行另外的任务时，它保存正在运行任务的当前状态，也就是CPU寄存器中的全部内容。这些内容被保存在任务自己的堆栈中，入栈工作完成后就把下一个将要运行的任务的当前状况从该任务的栈中重新装入CPU寄存器，并开始下一个任务的运行，这一过程就是context switch。

如图: 每个任务都是整个应用的一部分，都被赋予一定的优先级，有自己的一套CPU寄存器和栈空间。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/image-20220524200937130.png" width="30%"/>

### 1.4、并发与并行

- 并发：指应用能够交替执行不同的任务，比如单CPU核心下执行多线程并非是同时执行多个任务，如果你开两个线程执行，就是在你几乎不可能察觉到的速度不断去切换这两个任务，已达到“同时执行效果”，其实并不是的，只是计算机的速度太快，我们无法察觉到而已。
- 并行：指应用能够同时执行不同的任务。

  两者区别：一个是交5、高并发编程的意义、好处和注意事项

## 二、Java中线程创建方式

### 2.1、继承Thread类创建线程类

- 定义[Thread类](https://so.csdn.net/so/search?q=Thread%E7%B1%BB&spm=1001.2101.3001.7020)的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。
- 创建Thread[子类](https://so.csdn.net/so/search?q=%E5%AD%90%E7%B1%BB&spm=1001.2101.3001.7020)的实例，即创建了线程对象。
- 调用线程对象的start()方法来启动该线程。

```java
public class Test1_thread {
    
    public static void main(String[] args) throws InterruptedException {
        System.out.println("主方法的开头...");
        //外部类线程启动
        MyThread mt = new MyThread();
        mt.start();     //子程序 运行
        //内部类线程启动
        InnerThread it = new InnerThread();
        it.start();     //启动线程要用start(); -->jvm会自动的调用线程中的run()

        //匿名内部类
        Thread nmThread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <= 100; i++) {
                    System.out.println("匿名内部类中j的值为：" + i);
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        nmThread.start();

        for (int i = 0; i < 5; i++) {
            Thread.sleep(1000);
            System.out.println("主方法在运行...");
        }

    }

    //内部类 只有Test1_thread会用到
    static class InnerThread extends Thread {
        @Override
        public void run() {
            for (int i = 0; i <= 100; i++) {
                System.out.println("内部类中j的值为：" + i);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

//方案一：外部类 写一个类继承自Thread， 重写run()方法。在这个方法加入耗时的操作或阻塞操作
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i <= 100; i++) {
            System.out.println("i的值为：" + i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
//缺点：java是单继承，以上方法影响类的扩展性
```

### 2.2、通过Runnable接口创建线程类

- 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。
- 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。
- 调用线程对象的start()方法来启动该线程。

```java
package com.zhulin.thread;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * @program:大数据工作区
 * @description:
 * @author:ZHULIN
 * @create:2022-01-10 20:44
 */
public class Test2_Thread_runnable {
    public static void main(String[] args) {
        //方法一：继承Thread类
        ShowTimeThread stt = new ShowTimeThread();
        stt.setName("线程1--显示时间");     //设置线程名
        stt.setPriority(1);     //可以设置优先级（理论上） 1-10
        stt.start();

        //实现二：实现runnable接口  任务对象
        ShowTimeThread2 task = new ShowTimeThread2();
        //创建线程对象        任务      线程名
        Thread t = new Thread(task, "线程二--继承Runnable接口");
        t.setPriority(10);
        t.start();      //t启动，jvm就会自动回调它配置 task中的run()

        //实现二：换成匿名内部类写法
        Thread t2 = new Thread(new Runnable() {
            @Override
            public void run() {
                SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss");
                Date d = null;
                while (true) {
                    d = new Date();
                    System.out.println(Thread.currentThread().getName() + "当前的时间为：" + sdf.format(d));
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }, "线程3--匿名内部类");
        t2.start();

        //写法4：函数式编程  -> lambda写法
        Thread t3 = new Thread(() -> {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss");
            Date d = null;
            while (true) {
                d = new Date();
                System.out.println(Thread.currentThread().getName() + "当前的时间为：" + sdf.format(d));
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "线程4--函数式编程");
        t3.start();
    }
}

/**
 * 显示时间  线程类
 */
class ShowTimeThread extends Thread {
    @Override
    public void run() {
        //耗时操作
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss");
        Date d = null;
        //死循环
        while (true) {
            d = new Date();
            //Thread.currentThread().getName()  获取线程的名字
            System.out.println(Thread.currentThread().getName() + "当前时间为：" + sdf.format(d));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

/**
 * 方案二：写一个类(任务类) 实现Runnable接口，重写run()
 */
class ShowTimeThread2 implements Runnable {
    @Override
    //run加入在线程中完成的操作
    public void run() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss");
        Date d = null;
        while (true) {
            d = new Date();
            System.out.println(Thread.currentThread().getName() + "当前时间为：" + sdf.format(d));
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 2.3、通过Callable和Future创建线程

- 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。
- 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。
- 使用FutureTask对象作为Thread对象的target创建并启动新线程。
- 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

```java
public class Test03_callable {
    public static void main(String[] args) {
        //FutureTask对象
        //方式一：内部类
        FutureTask<Integer> task = new FutureTask<Integer>(new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                int count = 0;
                for (int i = 0; i <= 100; i++) {
                    Thread.sleep(100);
                    count += i;
                }
                return count;
            }
        });

        //方式二：Lambda表达式
        //FutureTask<Integer> task = new FutureTask<Integer>(() -> {
        //    int count = 0;
        //    for (int i = 0; i <= 100; i++) {
        //        Thread.sleep(100);
        //        count += i;
        //    }
        //    return count;
        //});

        //创建线程 与一个FutureTask任务绑定
        Thread thread = new Thread(task);
        //启动线程
        thread.start();
        try {
            //获取线程返回值
            //System.out.println("1+2+3+...+100=" + task.get());  //等到两种情况跳出  1.任务执行出异常  2.任务执行完
            System.out.println("1+2+3+...+100=" + task.get(20, TimeUnit.SECONDS)); //超时
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
        }
        //因为调用了get() 这是阻塞式的方法，它要等出结果后，主线程才会继续
        System.out.println("主程序中其他的代码......");
    }
}
```

#### 创建线程的三种方式的对比：

##### （1）采用实现Runnable、Callable接口的方式创建多线程时，

- **优势是：**
  线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
- **劣势是：**
  编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

##### （2）使用继承Thread类的方式创建多线程时

- **优势是：**
  编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
- **劣势是：**
  线程类已经继承了Thread类，所以不能再继承其他父类

## 三、并发三要素

### 3.1、可见性

  一个线程对共享变量的修改，另一个线程能够立刻看到。

```java
//线程1执行的代码
int i = 0;
i = 10;
 
//线程2执行的代码
j = i;
```

  假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。

此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

### 3.2、原子性：分时复用引起

  一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么都不执行。

### 3.3、有序性：指令重排序引起

  即程序执行的顺序按照代码的先后顺序执行。

```java
int i = 0;              
boolean flag = false;
i = 1;                //语句1  
flag = true;          //语句2
```

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。