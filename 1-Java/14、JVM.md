# JVM虚拟机原理与调优

## 一、JVM概念

### 1.1、什么是Java虚拟机？

 虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)（Java虚拟机）是一个抽象的计算模型。就如同一台真实的机器，它有自己的指令集和执行引擎，可以在运行时操控内存区域。目的是为构建在其上运行的应用程序提供一个运行环境。JVM可以解读指令代码并与底层进行交互：包括操作系统平台和执行指令并管理资源的硬件体系结构。

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。**JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。**

### 1.2、字节码文件

class文件是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中，然后JVM根据其特定的规则解析该二进制数据从而获取相关信息。

class文件采用一种伪结构来存储数据，有两种类型：无符号数和表。

#### class文件的结构属性

- **魔数与文件版本**：每个class文件的头4个字节称为魔数，值为：0×CAFEBABE。作用`是确定该文件是一个class文件`，主要是为了识别一个文件是否是特定的类型。许多类型的文件都有自己对应的“魔数”，列如图片格式的jpg，jpeg都在文件头存有魔数。
- **常量池**：相当于class文件的`资源仓库`，是class文件结构中关联最多的数据类型，也是占用class文件最大的数据项目之一。常量池存储的资源有：`变量的属性、类型和名称;方法的属性、类型和名称`等等。
- **访问标志**：表示该class的属性和访问类型，比如该class是类还是接口，它的访问类型是否为public，类型是否被标记为final。
- **类索引、父类索引、接口索引**：类索引、父类索引和接口索引可以简单的理解为一种描述的数据项目，class文件靠类索引、父类索引和接口索引这三项数据来确定这个类的继承关系。
- **字段表属性**：用于描述接口或类中声明的变量。比如变量的作用域（public、private、protected）、是否是静态变量（static）、可变性（final）、数据类型（基本类型、对象、数组）等等。
- **方法表属性**：与字段表类似，但是方法表描述的是方法的类型、作用域等等。
- **属性表属性**：用于描述某些场景专有的信息。比如字段表中特殊的属性、方法表中特殊的属性等等。

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("test");
    }
}
```

```java
cafe babe 0000 0034 0013 0a00 0400 0f09
0003 0010 0700 1107 0012 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100 0f4c 696e 654e
756d 6265 7254 6162 6c65 0100 0369 6e63
0100 0328 2949 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0007 0008 0c00 0500 0601 0010 636f 6d2f
7268 7974 686d 372f 4d61 696e 0100 106a
6176 612f 6c61 6e67 2f4f 626a 6563 7400
2100 0300 0400 0000 0100 0200 0500 0600
0000 0200 0100 0700 0800 0100 0900 0000
1d00 0100 0100 0000 052a b700 01b1 0000
0001 000a 0000 0006 0001 0000 0003 0001
000b 000c 0001 0009 0000 001f 0002 0001
0000 0007 2ab4 0002 0460 ac00 0000 0100
0a00 0000 0600 0100 0000 0800 0100 0d00
0000 0200 0e
```

- 文件开头的`4个字节("cafe babe")`称之为 魔数，唯有以"cafe babe"开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。
-  0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。

```shell
D:\IDEA工作区\JVM\test1\src\main\java\com\zhulin>java -version
java version "1.8.0_333"
Java(TM) SE Runtime Environment (build 1.8.0_333-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.333-b02, mixed mode)
```

### 1.3、字节码的装载过程

加载：查找并加载类的二进制数据

连接：

- 验证：确保被加载的类的正确性
- 准备：为类的静态变量分配内存，并将其初始化为默认值
- 解析：把类中的符号引用转化为直接引用
  - 符号引用：是一种间接引用，如一个类中的方法引用了另外一个类，这是一种符号的表述。
  - 直接引用：就是通过指针的方式，直接指向了目标对象内存的位置，能一下子找到特定的方法。

初始化：为类的静态变量赋予正确的初始值

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207091931556.png" alt="image-20220709193113975" style="width:50%;" />

### 1.4、JVM的内存模型

JVM 运行时内存共分为`虚拟机栈`、`堆`、`元空间`、`程序计数器`、`本地方法栈`五个部分。还有一部分内存叫`直接内存`，属于操作系统的本地内存，也是可以直接操作的。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207091520404.png" alt="image-20220709152016354" style="width:40%;" /><img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207120905053.png" alt="image-20220712090141479" style="width:40%;" />

**线程共享的：**`堆`、`方法区`、`直接内存`（非运行时数据区的一部分）

**线程私有的：**`程序计数器`、`虚拟机栈`、`本地方法栈`

- **元空间（方法区）**：

  本质和永久代类似，都是对JVM规范中方法区的实现。`元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存`。在jdk1.8以前，称为永久代，在1.8以后，称为元空间MateSpace，不由具名管理它的内存结构，而是交给操作系统内存，元空间使用的系统内存，元空间的串池StringTable被移到了堆内存中。线程共享，方法区逻辑上是堆的一部分，方法存储了更类结构相关的一些信息，比如常量，类变量，类的构造器，方法的信息，成员方法和构造方法，编译器编译后的代码等等，方法区如果内存不足也会报内存溢出。

- **虚拟机栈**：
  
  每个线程都有一个私有的栈，随着`线程的创建而创建`，`生命周期与线程相同`。栈里面存着的是一种叫“`栈帧`”的东西，每个方法都会创建一个栈帧，栈帧中存放了`局部变量表（基本数据类型和对象引用）、操作数栈、方法出口`等信息，栈帧与数据结构的栈类似，都是先进后出的数据结构，只支持出栈和入栈操作。栈的大小`可以固定也可以动态扩展`。
  
  - `局部变量表`：用来临时存储8个基本数据类型、对象引用地址、returnAddress类型，就是一些操作完成以后的数据，是一个数组结构。
  - `操作数栈`：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操作，读取我们的代码，进行计算后再放入局部变量表中去，临时来存放数据的。
  - `动态链接`：假如方法中有一个service.add()方法，要链接到别的地方去，这就是动态链接，存储链接的地方。
  
- **本地方法栈**：

  与虚拟机栈类似，区别是虚拟机栈执行Java方法，本地方法执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。

- **程序计数器**：

  程序计数器是一块`较小的内存空间`，可以看成是`当前线程所执行的字节码`的`行号指示器`。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。

  字节码解释器通过`改变程序计数器`来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。

  为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“`线程私有`”内存。在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次的运行位置。

  程序计数器是唯一不会出现`OutOfMemoryError`的内存区域，生命周期随着线程的创建而创建，随着线程的结束而死亡。

- **堆内存**：

  堆内存是 JVM 所有`线程共享的部分`，在虚拟机启动的时候就已经创建。`所有的对象和数组`都在堆上进行分配。这部分空间可通过`GC（垃圾回收器）`进行回收。当申请不到空间时会抛出 `OutOfMemoryError`。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。jdk1.8后，字符串常量池从永久代中剥离出来，存放在队中。

- **直接内存**：

  直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了`NIO(New Input/Output)`类，引入了一种基于`通道(Channel)与缓冲区（Buffer）的I/O `方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

### 1.5、JVM架构模型

Java编译器输入的指令流基本上是一种`基于栈`的指令集架构，另外一种指令集架构则是`基于寄存器`的指令集架构。

#### 基于栈的指令集架构

一个方法相当于一个入栈的操作，执行完相当于出栈操作

**基于栈式架构的特点：**

- 设计和实现更简单，适用于资源受限的系统；

- 避开了寄存器的分配难题：使用零地址指令方式分配

- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现

- 不需要硬件支持，可移植性更好，更好实现跨平台


#### 基于寄存器的指令级架构
**基于寄存器架构的特点：**

- 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。

- 指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差

- 性能优秀和执行更高效

- 花费更少的指令去完成一项操作

- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主



## 二、类加载

### 2.1、类的生命周期

类加载的过程有加载、验证、准备、解析、初始化五个阶段。五个阶段中只有解析的顺序不一定，其余的阶段都是按顺序开始的，解析阶段可以在初始化之后开始，是为了支持Java语言中的运行时绑定（动态绑定或晚期绑定）。五个阶段通常都是互相交叉地混合进行的，在一个阶段执行的过程中调用或激活另一个阶段。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207112104961.png" alt="image-20220711210424667" style="width:50%;" /><img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207102221165.png" alt="image-20220710222153284" style="width:50%;" />

#### 类的加载：查找并加载类的二进制数据

- 通过一个类的全限定名来获取其定义的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207112108187.png" alt="image-20220711210828996" style="width:50%;" />

加载阶段（准确来讲：是`加载阶段获取类的二进制字节流的动作`）是`可控性最强`的阶段，该阶段开放人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。(`加载方法多样`)

加载阶段完成后，虚拟机外部的二进制字节流就会按照虚拟机所需的`格式存储`在`方法区`之中，并且在java堆中也创建一个`java.lang.Class`类的对象，如此便可以通过该对象访问方法区中的这些数据。(`方便访问`)

类加载器并不需要等待某个类被“首次主动使用”时才加载它。在JVM规范中允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误，若该该类一直未被程序使用，则类加载器不会报告错误。

> 加载Class文件的方式

- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip、jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件

#### 连接

##### 验证：确保被加载的类的正确性

确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0×CAFEBABY开头（验证是否是.class文件）、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义优化，以保证其描述的信息符合Java语言规范的要求。例如，这个类是否有父类，除了`java.lang.Object`之外。
- 字节码验证：通过字节流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

> 验证阶段是非常重要的，但不是必须的，它对程序运行期间是没有影响的，如果引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机加载的时间。

##### 准备：为类的静态变量分配内存，并将其初始化为默认值

该阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

- 进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
- 初始化的默认值是数据类型所具有的默认的零值（0、0L、null、false等），而不是被在Java代码中被显示地赋予的值。

> public static int value = `3`；变量value在准备阶段过后的初始值为`0`，而不是3，这个时候并`未开始`执行任何Java方法，而把value赋值为3的`put static`指令是在程序编译后，存放于类构造器`<clinit>()`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

- 对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
- 对于同时被`static`和`final`修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
- 对于引用数据类型`reference`来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即`null`。
- 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
- 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: `public static final int value = 3；`编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为`static final`常量在编译期就将其结果放入了调用它的类的常量池中

##### 解析：将类中的符号引用转化为直接引用

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对`类`或`接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用点`限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

`直接引用`就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

#### 初始化

为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

- 声明类是指定初始值。
- 使用静态代码块为类变量指定初始值。

#### 初始化步骤

- 假如这个类还没有被加载和连接，则程序先加载并连接该类。
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类。
- 假如类中有初始化语句，则系统依次执行这些初始化语句。

#### 类初始化的时机

只有当对类的主动使用的时候才会导致类的初始化，类的主动使用有以下：

- 创建类的实例，new。
- 访问某个类或接口的静态变量、或者对该静态变量赋值。
- 调用类的静态方法。
- 反射（如Class.forName("com.zhulin.Test")）。
- 初始化某个类的子类，则其父类也会被初始化。
- Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exec命令来运行某个主类。

#### 卸载

**Java虚拟机将结束生命周期的几种情况**

- 执行了System.exit()方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止

### 2.2、类加载器的分类

**启动类/引导类（BootStrap ClassLoader）**

这个类加载器使用C/C++语言实现，嵌套在JVM内部，java程序无法直接操作这个类，是用来加载Java核心类库。如：`JAVA_HOME/jre/lib/rt.jar`、`resources.jar`、`sun.boot.class.path`路径下的包，用于提供jvm运行所需的包。没有继承`java.lang.ClassLoader`，也没有父类加载器。它加载`扩展类加载器`和`应用程序类加载器`，并成为他们的父类加载器。出于安全考虑，启动类只加载包名为：java、javax、sun开头的类。

**扩展类加载器（Extension ClassLoader）**

由`sun.misc.Launcher$ExtClassLoader`实现，派生继承自java.lang.ClassLoader，父类加载器为`启动类加载器`。加载从`java.ext.dirs`目录中加载类库，或者从JDK安装目录下`jre/lib/ext`加载类库。将自定义的包放在以上目录下，也会自动加载进去。

**应用程序类加载器（Application ClassLoader）**

由`sun.misc.Launcher$AppClassLoader`实现。派生继承自java.lang.ClassLoader，父类加载器为`启动类加载器`。负责加载`环境变量classpath`和`系统属性java.class.path`指定路径下的类库。是程序中默认的类加载器，Java程序中的类都由该加载器加载完成。通过`ClassLoader#getSystemClassLoader()`获取并操作这个加载器。

**自定义类加载器**

实现步骤：继承`java.lang.ClassLoader`类，重写findClass()方法，如果没有太复杂的需求，可以直接继承`URLClassLoader`类，重写`loadClass`方法，具体可参考`AppClassLoader`和`ExtClassLoader`。

### 2.3、获取ClassLoader的方式

```java
// 方式一：获取当前类的 ClassLoader
clazz.getClassLoader()
// 方式二：获取当前线程上下文的 ClassLoader
Thread.currentThread().getContextClassLoader()
// 方式三：获取系统的 ClassLoader
ClassLoader.getSystemClassLoader()
// 方式四：获取调用者的 ClassLoader
DriverManager.getCallerClassLoader()
```

## 三、类加载之双亲委派

### 3.1、双亲委派模型

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207111257384.png" alt="image-20220711125701988" style="width:40%;" />

1. 一个类加载器接收到了类加载的请求，这个类加载器不会先去尝试加载这个类，而是会把这个请求委托给自己的父类加载器去执行。
2. 在每个层次的类加载器都是依次类推的，因此所有的类加载器请求最后都会被委托到顶层的启动类加载器中。
3. 如果父类加载器可以完成加载任务，则返回成功结果，如果父类加载失败，就由子类去尝试加载，子类加载失败就会抛出`ClassNotFoundException异常`。

### 3.2、双亲委派机制的作用

对于任意一个类，都需要由加载它的类和这个类本身一同确立其在Java虚拟机中的唯一性。当比较这个两个类是否相等的时候，前提是：只有在这个两个类是由同一个类加载器加载为前提下才有意义的。

```java
public class String {
    public static void main(String[] args) {
        System.out.println("String类测试");
    }
}

//报错
错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application
```

1. 保证JVM提供的核心类不被篡改，保证class执行安全。
2. 防止重复加载同一个class

## 四、JVM垃圾回收机制

### 4.1、如何判断垃圾可以回收？

- **引用计数**：给对象一个计数器，但是难以解决对象之间循环引用的问题，会造成内存泄露。
- **可达性分析**：java虚拟机中的垃圾回收器采用的是这种算法，判断GC ROOT是否有相连的引用链，如果没有就回收。
- 四种引用（强度递减）
  - `强引用`：只要沿着GC ROOT引用链，就不能被回收。
  - `软引用`：只要没有被强引用引用，就可能会被回收，当垃圾回收时，内存不够就回收。软引用本身也是一个对象，当软引用对象被回收时，软引用会进入引用队列。
  - `弱引用`：只要没有被强引用引用，就可能会被回收，当垃圾回收时，不管内存够不够都回收，同理，软引用也会进入引用队列。
  - `虚引用`：必须配合引用队列使用，当虚引用对象创建时，就会关联一个引用队列，主要配置终结器引用，必须配置引用队列使用。

### 4.2、垃圾回收算法（GC算法）

从如何判定对象消亡的角度看，垃圾回收算法可分为**“引用计数式垃圾回收”**和**”追踪式垃圾回收“**两大类，也称为“注解垃圾回收和间接垃圾回收。主流虚拟机采用追踪式垃圾回收算法。

**追踪式垃圾回收算法**的策略`并非是寻找垃圾本身`，而是先寻找`那些对象存活`，然后`反过来判断`其余所有的对象为垃圾对象。追踪式垃圾回收算法包括标记-清除算法、标记-复制算法、标记-整理算法。

#### 标记-清除算法

**原理：**标记-清除算法是最早出现也是最基础的垃圾回收算法，分为”标记“和”清除“两个阶段，首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收未标记的对象。

**缺点：**

`执行效率不稳定`，若java堆中包含大量对象，而且其中大部分是需要回收的，这是必须进行大量标记和清除的工作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。

`内存空间的碎片问题`。标记、清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 标记-复制算法

**原理：**复制算法就是把将内存分为2块等同大小的内存空间（A和B），使用A进行内存的使用，当A部分的内存不足以分配对象而引起内存回收时，就会将存活的对象从A内存块中放到B内存块中，然后把A内存中的对象全部清除。同理在B内存中使用也是如此。` 使用该方法能避免出现空间碎片（内存中不连续的空间）`。

**缺点：**空间得不到合理利用，`浪费了一半的内存`，降低了空间的使用率。

> 新生代中的对象大多数是朝生夕死的，复制算法中并`不需要按照1:1的比例`来划分内存空间，而是将内存分为`一块较大的Eden空间和两块较小的Survivor空间`，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。`HotSpot虚拟机默认Eden和Survivor的大小比例是8:1`，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要`依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）`。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些`对象将直接通过分配担保机制进入老年代。`

#### 标记-整理算法

**原理：**该算法与标记-清除算法中的标记过程一致，在后续过程中不是直接对可回收对象进行清理，而是让所有存货的对象都向内存空间一段移动，然后直接清理掉边界以外的内存。

**缺点：**该算法虽然避免了空间碎片的产生，也避免了标记-复制算法中的内存浪费问题，但`存在严重的效率问题`，该算法的效率比前两种都慢。

目前商业虚拟机的垃圾回收器，大多数都遵循`”分代收集“`的理论进行设计的。将Java堆划分为老年代和新生代两个区域，在新生代中每次垃圾回收时都会发现有大批对象死去，而每次在垃圾回收后存活的少量对象，将会逐步晋升到老年代中存放。