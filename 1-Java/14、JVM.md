# JVM虚拟机原理与调优

## 一、JVM概念

### 1.1、什么是Java虚拟机？

 虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)（Java虚拟机）是一个抽象的计算模型。就如同一台真实的机器，它有自己的指令集和执行引擎，可以在运行时操控内存区域。目的是为构建在其上运行的应用程序提供一个运行环境。JVM可以解读指令代码并与底层进行交互：包括操作系统平台和执行指令并管理资源的硬件体系结构。

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。**JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。**

### 1.2、字节码文件

class文件是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中，然后JVM根据其特定的规则解析该二进制数据从而获取相关信息。

class文件采用一种伪结构来存储数据，有两种类型：无符号数和表。

#### class文件的结构属性

- **魔数与文件版本**：每个class文件的头4个字节称为魔数，值为：0×CAFEBABE。作用`是确定该文件是一个class文件`，主要是为了识别一个文件是否是特定的类型。许多类型的文件都有自己对应的“魔数”，列如图片格式的jpg，jpeg都在文件头存有魔数。
- **常量池**：相当于class文件的`资源仓库`，是class文件结构中关联最多的数据类型，也是占用class文件最大的数据项目之一。常量池存储的资源有：`变量的属性、类型和名称;方法的属性、类型和名称`等等。
- **访问标志**：表示该class的属性和访问类型，比如该class是类还是接口，它的访问类型是否为public，类型是否被标记为final。
- **类索引、父类索引、接口索引**：类索引、父类索引和接口索引可以简单的理解为一种描述的数据项目，class文件靠类索引、父类索引和接口索引这三项数据来确定这个类的继承关系。
- **字段表属性**：用于描述接口或类中声明的变量。比如变量的作用域（public、private、protected）、是否是静态变量（static）、可变性（final）、数据类型（基本类型、对象、数组）等等。
- **方法表属性**：与字段表类似，但是方法表描述的是方法的类型、作用域等等。
- **属性表属性**：用于描述某些场景专有的信息。比如字段表中特殊的属性、方法表中特殊的属性等等。

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("test");
    }
}
```

```java
cafe babe 0000 0034 0013 0a00 0400 0f09
0003 0010 0700 1107 0012 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100 0f4c 696e 654e
756d 6265 7254 6162 6c65 0100 0369 6e63
0100 0328 2949 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0007 0008 0c00 0500 0601 0010 636f 6d2f
7268 7974 686d 372f 4d61 696e 0100 106a
6176 612f 6c61 6e67 2f4f 626a 6563 7400
2100 0300 0400 0000 0100 0200 0500 0600
0000 0200 0100 0700 0800 0100 0900 0000
1d00 0100 0100 0000 052a b700 01b1 0000
0001 000a 0000 0006 0001 0000 0003 0001
000b 000c 0001 0009 0000 001f 0002 0001
0000 0007 2ab4 0002 0460 ac00 0000 0100
0a00 0000 0600 0100 0000 0800 0100 0d00
0000 0200 0e
```

- 文件开头的4个字节("cafe babe")称之为 魔数，唯有以"cafe babe"开头的class文件方可被虚拟机所接受，这4个字节就是字节码文件的身份识别。
-  0000是编译器jdk版本的次版本号0，0034转化为十进制是52,是主版本号，java的版本号从45开始，除1.0和1.1都是使用45.x外,以后每升一个大版本，版本号加一。也就是说，编译生成该class文件的jdk版本为1.8.0。

```shell
D:\IDEA工作区\JVM\test1\src\main\java\com\zhulin>java -version
java version "1.8.0_333"
Java(TM) SE Runtime Environment (build 1.8.0_333-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.333-b02, mixed mode)
```

### 1.3、字节码的装载过程

加载：查找并加载类的二进制数据

连接：

- 验证：确保被加载的类的正确性
- 准备：为类的静态变量分配内存，并将其初始化为默认值
- 解析：把类中的符号引用转化为直接引用
  - 符号引用：是一种间接引用，如一个类中的方法引用了另外一个类，这是一种符号的表述。
  - 直接引用：就是通过指针的方式，直接指向了目标对象内存的位置，能一下子找到特定的方法。

初始化：为类的静态变量赋予正确的初始值

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207091931556.png" alt="image-20220709193113975" style="width:50%;" />

### 1，4、JVM的内存模型

JVM 运行时内存共分为虚拟机栈、堆、元空间、程序计数器、本地方法栈五个部分。还有一部分内存叫直接内存，属于操作系统的本地内存，也是可以直接操作的。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207091520404.png" alt="image-20220709152016354" style="width:40%;" />

- **元空间（方法区）**：本质和永久代类似，都是对JVM规范中方法区的实现。元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。在jdk1.8以前，称为永久代，在1.8以后，称为元空间MateSpace，不由具名管理它的内存结构，而是交给操作系统内存，元空间使用的系统内存，元空间的串池StringTable被移到了堆内存中。线程共享，方法区逻辑上是堆的一部分，方法存储了更类结构相关的一些信息，比如常量，类变量，类的构造器，方法的信息，成员方法和构造方法，编译器编译后的代码等等，方法区如果内存不足也会报内存溢出
- **虚拟机栈**：每个线程都有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法都会创建一个栈帧，栈帧中存放了`局部变量表（基本数据类型和对象引用）、操作数栈、方法出口`等信息。栈的大小可以固定也可以动态扩展。
  - `局部变量表`：用来临时存储8个基本数据类型、对象引用地址、returnAddress类型，就是一些操作完成以后的数据，是一个数组结构。
  - `操作数栈`：操作数栈就是用来操作的，例如代码中有个 i = 6*6，他在一开始的时候就会进行操作，读取我们的代码，进行计算后再放入局部变量表中去，临时来存放数据的。
  - `动态链接`：假如方法中有一个service.add()方法，要链接到别的地方去，这就是动态链接，存储链接的地方。
- **本地方法栈**：与虚拟机栈类似，区别是虚拟机栈执行Java方法，本地方法执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。
- **程序计数器**：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。
- **堆内存**：堆内存是 JVM 所有`线程共享的部分`，在虚拟机启动的时候就已经创建。`所有的对象和数组`都在堆上进行分配。这部分空间可通过`GC（垃圾回收器）`进行回收。当申请不到空间时会抛出 `OutOfMemoryError`。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。jdk1.8后，字符串常量池从永久代中剥离出来，存放在队中。
- **直接内存**：直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了`NIO(New Input/Output)`类，引入了一种基于`通道(Channel)与缓冲区（Buffer）的I/O `方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

### 1.5、JVM架构模型

Java编译器输入的指令流基本上是一种`基于栈`的指令集架构，另外一种指令集架构则是`基于寄存器`的指令集架构。

#### 基于栈的指令集架构

一个方法相当于一个入栈的操作，执行完相当于出栈操作

**基于栈式架构的特点：**

- 设计和实现更简单，适用于资源受限的系统；

- 避开了寄存器的分配难题：使用零地址指令方式分配

- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现

- 不需要硬件支持，可移植性更好，更好实现跨平台


#### 基于寄存器的指令级架构
**基于寄存器架构的特点：**

- 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。

- 指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差

- 性能优秀和执行更高效

- 花费更少的指令去完成一项操作

- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主



## 二、类加载

### 2.1、类的生命周期

类加载的过程有加载、验证、准备、解析、初始化五个阶段。五个阶段中只有解析的顺序不一定，其余的阶段都是按顺序开始的，解析阶段可以在初始化之后开始，是为了支持Java语言中的运行时绑定（动态绑定或晚期绑定）。五个阶段通常都是互相交叉地混合进行的，在一个阶段执行的过程中调用或激活另一个阶段。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207112104961.png" alt="image-20220711210424667" style="width:60%;" />

#### 类的加载：查找并加载类的二进制数据

- 通过一个类的全限定名来获取其定义的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207112108187.png" alt="image-20220711210828996" style="width:50%;" />

加载阶段（准确来讲：是`加载阶段获取类的二进制字节流的动作`）是`可控性最强`的阶段，该阶段开放人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。(`加载方法多样`)

加载阶段完成后，虚拟机外部的二进制字节流就会按照虚拟机所需的`格式存储`在`方法区`之中，并且在java堆中也创建一个`java.lang.Class`类的对象，如此便可以通过该对象访问方法区中的这些数据。(`方便访问`)

类加载器并不需要等待某个类被“首次主动使用”时才加载它。在JVM规范中允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误，若该该类一直未被程序使用，则类加载器不会报告错误。

> 加载Class文件的方式

- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip、jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件

#### 连接

##### 验证：确保被加载的类的正确性

确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0×CAFEBABY开头（验证是否是.class文件）、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义优化，以保证其描述的信息符合Java语言规范的要求。例如，这个类是否有父类，除了`java.lang.Object`之外。
- 字节码验证：通过字节流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

> 验证阶段是非常重要的，但不是必须的，它对程序运行期间是没有影响的，如果引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机加载的时间。

##### 准备：为类的静态变量分配内存，并将其初始化为默认值

该阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

- 进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
- 初始化的默认值是数据类型所具有的默认的零值（0、0L、null、false等），而不是被在Java代码中被显示地赋予的值。

> public static int value = `3`；变量value在准备阶段过后的初始值为`0`，而不是3，这个时候并`未开始`执行任何Java方法，而把value赋值为3的`put static`指令是在程序编译后，存放于类构造器`<clinit>()`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

- 对基本数据类型来说，对于类变量(static)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
- 对于同时被`static`和`final`修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。
- 对于引用数据类型`reference`来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即`null`。
- 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
- 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。假设上面的类变量value被定义为: `public static final int value = 3；`编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为`static final`常量在编译期就将其结果放入了调用它的类的常量池中

##### 解析：将类中的符号引用转化为直接引用

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对`类`或`接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用点`限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

`直接引用`就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

#### 初始化

为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

- 声明类是指定初始值。
- 使用静态代码块为类变量指定初始值。

#### 初始化步骤

- 假如这个类还没有被加载和连接，则程序先加载并连接该类。
- 假如该类的直接父类还没有被初始化，则先初始化其直接父类。
- 假如类中有初始化语句，则系统依次执行这些初始化语句。

#### 类初始化的时机

只有当对类的主动使用的时候才会导致类的初始化，类的主动使用有以下：

- 创建类的实例，new。
- 访问某个类或接口的静态变量、或者对该静态变量赋值。
- 调用类的静态方法。
- 反射（如Class.forName("com.zhulin.Test")）。
- 初始化某个类的子类，则其父类也会被初始化。
- Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exec命令来运行某个主类。

#### 卸载

**Java虚拟机将结束生命周期的几种情况**

- 执行了System.exit()方法
- 程序正常执行结束
- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止

### 2.2、类加载器的分类

**启动类/引导类（BootStrap ClassLoader）**

这个类加载器使用C/C++语言实现，嵌套在JVM内部，java程序无法直接操作这个类，是用来加载Java核心类库。如：`JAVA_HOME/jre/lib/rt.jar`、`resources.jar`、`sun.boot.class.path`路径下的包，用于提供jvm运行所需的包。没有继承`java.lang.ClassLoader`，也没有父类加载器。它加载`扩展类加载器`和`应用程序类加载器`，并成为他们的父类加载器。出于安全考虑，启动类只加载包名为：java、javax、sun开头的类。

**扩展类加载器（Extension ClassLoader）**

由`sun.misc.Launcher$ExtClassLoader`实现，派生继承自java.lang.ClassLoader，父类加载器为`启动类加载器`。加载从`java.ext.dirs`目录中加载类库，或者从JDK安装目录下`jre/lib/ext`加载类库。将自定义的包放在以上目录下，也会自动加载进去。

**应用程序类加载器（Application ClassLoader）**

由`sun.misc.Launcher$AppClassLoader`实现。派生继承自java.lang.ClassLoader，父类加载器为`启动类加载器`。负责加载`环境变量classpath`和`系统属性java.class.path`指定路径下的类库。是程序中默认的类加载器，Java程序中的类都由该加载器加载完成。通过`ClassLoader#getSystemClassLoader()`获取并操作这个加载器。

**自定义类加载器**

实现步骤：继承`java.lang.ClassLoader`类，重写findClass()方法，如果没有太复杂的需求，可以直接继承`URLClassLoader`类，重写`loadClass`方法，具体可参考`AppClassLoader`和`ExtClassLoader`。

### 2.3、获取ClassLoader的方式

```java
// 方式一：获取当前类的 ClassLoader
clazz.getClassLoader()
// 方式二：获取当前线程上下文的 ClassLoader
Thread.currentThread().getContextClassLoader()
// 方式三：获取系统的 ClassLoader
ClassLoader.getSystemClassLoader()
// 方式四：获取调用者的 ClassLoader
DriverManager.getCallerClassLoader()
```

## 三、类加载之双亲委派

### 3.1、双亲委派模型

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207111257384.png" alt="image-20220711125701988" style="width:40%;" />

1. 一个类加载器接收到了类加载的请求，这个类加载器不会先去尝试加载这个类，而是会把这个请求委托给自己的父类加载器去执行。
2. 在每个层次的类加载器都是依次类推的，因此所有的类加载器请求最后都会被委托到顶层的启动类加载器中。
3. 如果父类加载器可以完成加载任务，则返回成功结果，如果父类加载失败，就由子类去尝试加载，子类加载失败就会抛出`ClassNotFoundException异常`。

### 3.2、双亲委派机制的作用

对于任意一个类，都需要由加载它的类和这个类本身一同确立其在Java虚拟机中的唯一性。当比较这个两个类是否相等的时候，前提是：只有在这个两个类是由同一个类加载器加载为前提下才有意义的。

```java
public class String {
    public static void main(String[] args) {
        System.out.println("String类测试");
    }
}

//报错
错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application
```

1. 保证JVM提供的核心类不被篡改，保证class执行安全。
2. 防止重复加载同一个class

## 四、JVM垃圾回收机制

### 4.1、如何判断垃圾可以回收？

- **引用计数**：给对象一个计数器，但是难以解决对象之间循环引用的问题，会造成内存泄露。
- **可达性分析**：java虚拟机中的垃圾回收器采用的是这种算法，判断GC ROOT是否有相连的引用链，如果没有就回收。
- 四种引用（强度递减）
  - `强引用`：只要沿着GC ROOT引用链，就不能被回收。
  - `软引用`：只要没有被强引用引用，就可能会被回收，当垃圾回收时，内存不够就回收。软引用本身也是一个对象，当软引用对象被回收时，软引用会进入引用队列。
  - `弱引用`：只要没有被强引用引用，就可能会被回收，当垃圾回收时，不管内存够不够都回收，同理，软引用也会进入引用队列。
  - `虚引用`：必须配合引用队列使用，当虚引用对象创建时，就会关联一个引用队列，主要配置终结器引用，必须配置引用队列使用。

### 4.2、垃圾回收算法（GC算法）

从如何判定对象消亡的角度看，垃圾回收算法可分为**“引用计数式垃圾回收”**和**”追踪式垃圾回收“**两大类，也称为“注解垃圾回收和间接垃圾回收。主流虚拟机采用追踪式垃圾回收算法。

**追踪式垃圾回收算法**的策略`并非是寻找垃圾本身`，而是先寻找`那些对象存活`，然后`反过来判断`其余所有的对象为垃圾对象。追踪式垃圾回收算法包括标记-清除算法、标记-复制算法、标记-整理算法。

#### 标记-清除算法

**原理：**标记-清除算法是最早出现也是最基础的垃圾回收算法，分为”标记“和”清除“两个阶段，首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收未标记的对象。

**缺点：**

`执行效率不稳定`，若java堆中包含大量对象，而且其中大部分是需要回收的，这是必须进行大量标记和清除的工作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。

`内存空间的碎片问题`。标记、清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 标记-复制算法

**原理：**复制算法就是把将内存分为2块等同大小的内存空间（A和B），使用A进行内存的使用，当A部分的内存不足以分配对象而引起内存回收时，就会将存活的对象从A内存块中放到B内存块中，然后把A内存中的对象全部清除。同理在B内存中使用也是如此。` 使用该方法能避免出现空间碎片（内存中不连续的空间）`。

**缺点：**空间得不到合理利用，`浪费了一半的内存`，降低了空间的使用率。

> 新生代中的对象大多数是朝生夕死的，复制算法中并`不需要按照1:1的比例`来划分内存空间，而是将内存分为`一块较大的Eden空间和两块较小的Survivor空间`，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。`HotSpot虚拟机默认Eden和Survivor的大小比例是8:1`，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。当然，并不能保证每次回收都只有10%的对象存活，当Survivor空间不够用时，需要`依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）`。即如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些`对象将直接通过分配担保机制进入老年代。`

#### 标记-整理算法

**原理：**该算法与标记-清除算法中的标记过程一致，在后续过程中不是直接对可回收对象进行清理，而是让所有存货的对象都向内存空间一段移动，然后直接清理掉边界以外的内存。

**缺点：**该算法虽然避免了空间碎片的产生，也避免了标记-复制算法中的内存浪费问题，但`存在严重的效率问题`，该算法的效率比前两种都慢。

目前商业虚拟机的垃圾回收器，大多数都遵循`”分代收集“`的理论进行设计的。将Java堆划分为老年代和新生代两个区域，在新生代中每次垃圾回收时都会发现有大批对象死去，而每次在垃圾回收后存活的少量对象，将会逐步晋升到老年代中存放。















##Q&A

### 未来JDK的新技术发展

#### 新一代即时编译器

Graal编译器比C2编译器晚了足足二十年面世，有着极其充沛的后发优势，在保持输出相近质量的编译代码的同时，开发效率和扩展性上都要显著优于C2编译器，这决定了C2编译器中优秀的代码优化技术可以轻易地移植到Graal编译器上，但是反过来Graal编译器中行之有效的优化在C2编译器里实现起来则异常艰难。这种情况下，Graal的编译效果短短几年间迅速追平了C2，甚至某些测试项中开始逐渐反超C2编译器。Graal能够做比C2更加复杂的优化，如“部分逃逸分析”（Partial Escape Analysis），也拥有比C2更容易使用激进预测性优化（Aggressive Speculative Optimization）的策略，支持自定义的预测性假设等。 

#### 向Native迈进

经陆续推出了跨进程的、可以面向用户程序的类型信息共享（Application Class Data Sharing，AppCDS，允许把加载解析后的类型信息缓存起来，从而提升下次启动速度，原本CDS只支持Java标准库，在JDK 10时的AppCDS开始支持用户的程序代码）、无操作的垃圾收集器（Epsilon，只做内存分配而不做回收的收集器，对于运行完就退出的应用十分合适）等改善措施。而酝酿中的一个更彻底的解决方案，是逐步开始对提前编译（Ahead of Time Compilation，AOT）提供支持。 

提前编译是相对于即时编译的概念，提前编译能带来的最大好处是Java虚拟机加载这些已经预编译成二进制库之后就能够直接调用，而无须再等待即时编译器在运行时将其编译成二进制机器码。理论上，提前编译可以减少即时编译带来的预热时间，减少Java应用长期给人带来的“第一次运行慢”的不良体验，可以放心地进行很多全程序的分析行为，可以使用时间压力更大的优化措施。

提前编译的缺点：降低了Java链接过程的动态性，必须要求加载的代码在编译期是全部已知的，而不能在运行期才确定。

### JVM种类，目前使用的哪种，特点？

**种类**：Sun Classic/Exact VM、Exact VM、HotSpot VM、Mobile/Embedded VM 、BEA JRockit/IBM J9 VM 、BEA Liquid VM/Azul VM、

我们采用的是`HotSpot`，名称中的HotSpot指的就是它的**热点代码探测技术**

- 通过计数器找到最具编译价值代码，触发即时编译或栈上替换
- 通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡

### 为什么叫java虚拟机，与VMware的区别

**虚拟机**

所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。

- 大名鼎鼎的Visual Box，VMware就属于系统虚拟机，它们完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台
- 程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令

无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。

**Java虚拟机**

 虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)（Java虚拟机）是一个抽象的计算模型。就如同一台真实的机器，它有自己的指令集和执行引擎，可以在运行时操控内存区域。目的是为构建在其上运行的应用程序提供一个运行环境。JVM可以解读指令代码并与底层进行交互：包括操作系统平台和执行指令并管理资源的硬件体系结构。

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。**JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。**

Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。

JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。

Java技术的核心就是Java虚拟机（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。

Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。

特点：

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能

### java虚拟机的整体架构

### 字节码的加载流程？

### java的编译器输入的指令流是一种基于栈的指令集架构，有什么优点？

### 能运行在虚拟机上的字节码只能由javac编译而来的java源代码产生吗，其他语言？

不是，



## 类加载相关
### jvm在什么情况下会加载一个类?

什么是类加载；为什么会发生类加载；什么情况下发生类加载；

Java要运行，必须把源文件（.java）编译成字节码（.class），jvm的输入是字节码文件，需要把字节码文件加载到jvm内存中，要如何解析字节码文件，按照什么样的规则去解析，解析后放在内存中的什么位置，这些过程可以理解为类加载。一个java文件要运行必须通过类加载的过程，转化为JVM可以识别的数据结构。

为什么发生类加载，是由于要运行java程序，jvm不能识别java源程序，编译后的字节码文件jvm可以识别，但是要转化为jvm可以识别的数据结构，所以有类加载的过程。



java程序对类的使用分为主动使用和被动使用，只有主动使用才会发生类加载

1. 访问类的静态变量与静态方法，如果类没有加载，则首先会执行类加载
2. 初始化一个类的子类的时候，如果子类没有加载，则首先会执行子类的加载
3. 使用new关键字，生成一个对象，如果该类没有加载，则首先会加载该类
4. 使用反射，Class.forName()；如果该类没有加载，则执行该类的加载
5. 标记为启动类的加载，如果没有加载则首先执行该类的加载，常见的是main方法所在的类















### 类加载到jvm中的过程?每个阶段的工作?

加载---验证---准备---解析---初始化---使用---卸载

```java
public class Test {
    static int age;

    public static void main(String[] args) {
        NewTest newTest = new NewTest();
    }

    static class NewTest {

    }
}
```

<img src="https://knowledgeimagebed.oss-cn-hangzhou.aliyuncs.com/img/202207102221165.png" alt="image-20220710222153284" style="width:40%;" />

**加载**

执行类构造器 方法，如果赋值运算是通过其他类的静态方法来完成的，那么会马上解析另外一个类，在虚拟机栈中执行完毕后通过返回值进行赋值

类加载是一个将.class字节码文件实例化成Class对象并进行相关初始化的过程。

在这个过程中，[JVM](https://so.csdn.net/so/search?q=JVM&spm=1001.2101.3001.7020)会初始化继承树上还没有被初始化过的所有父类，并且会执行这个链路上所有未执行过的静态代码块、静态变量赋值语句等。

**加载过程中,JVM主要做3件事情**

- 通过一个类的全限定名来获取定义此类的二进制字节流(class文件)
  在程序运行过程中,当要访问一个类时,若发现这个类尚未被加载,并满足类初始化的条件时，就根据要被初始化的这个类的全限定名找到该类的二进制字节流,开始加载过程
- 将这个字节流的静态存储结构转化为方法区的运行时数据结构
- 在内存中创建一个该类的java.lang.Class对象,作为方法区该类的各种数据的访问入口

**验证**

保证二进制字节流中的信息符合虚拟机规范,并没有安全问题

- 文件格式验证
  验证字节流是否符合Class文件格式的规范,并且能被当前的虚拟机处理.
  本验证阶段是基于二进制字节流进行的,只有`通过本阶段验证,才被允许存到方法区`
  后面的三个验证阶段都是基于方法区的存储结构进行,不会再直接操作字节流。
- 元数据验证
  对字节码描述信息进行语义分析,确保符合Java语法规范.
- 字节码验证
  本阶段是验证过程的最复杂的一个阶段.
  本阶段对方法体进行语义分析,保证方法在运行时不会出现危害虚拟机的事件.
  字节码验证将对类的方法进行校验分析，保证被校验的方法在运行时不会做出危害虚拟机的事，一个类方法体的字节码没有通过字节码验证，那一定有问题，但若一个方法通过了验证，也不能说明它一定安全
- 符号引用验证
  发生在JVM将符号引用转化为直接引用的时候,这个转化动作发生在解析阶段,对类自身以外的信息进行匹配校验,确保解析能正常执行.

**准备**

- 为已在方法区中的类的静态成员变量分配内存
- 为静态成员变量设置初始值
  初始值为0、false、null等

**解析**

解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程.

**初始化**

真正开始执行类中定义的Java程序代码(或者说是字节码)
初始化阶段就是执行类构造器clinit()的过程.

clinit()方法由编译器自动产生，收集类中static{}代码块中的类变量赋值语句和类中静态成员变量的赋值语句。在准备阶段，类中静态成员变量已经完成了默认初始化，而在初始化阶段，clinit()方法对静态成员变量进行显示初始化。









































### jvm中的类加载器的类型及它加载的目标路径?如何自定义一个类加载器加载一个指定目录下的class文件?



### 什么是双亲委派模型，有什么作用?

### 类加载器是如何确定一个类在jvm中的唯一性的? 两个类来源于同一个Class文件，被同一个虚拟机加载,这两个类一定相等吗?

### tomcat的类加载器有哪些?































双亲委派模型最大问题：底层的类加载器无法加载底层的类, 比如如下情况:
     javax.xml.parsers包中定义了xml解析的类接口, Service Provider Interface SPI 位于rt.jar 
  即接口在启动ClassLoader中,  而SPI的实现类，通常是由用户实现的， 由AppLoader加载。 

   以下是javax.xmlparsers.FactoryFinder中的解决代码:  
   static private Class getProviderClass(String className, ClassLoader cl,
    boolean doFallback, boolean useBSClsLoader) throws ClassNotFoundException
{
  try {
    if (cl == null) {
      if (useBSClsLoader) {
        return Class.forName(className, true, FactoryFinder.class.getClassLoader());
      } else {
        cl = ss.getContextClassLoader();      //获取上下文加载器
        if (cl == null) {
          throw new ClassNotFoundException();
        }
        else {
          return cl.loadClass(className);   //使用上下文ClassLoader
        }
      }
    }
    else {
      return cl.loadClass(className);
    }
  }
  catch (ClassNotFoundException e1) {
    if (doFallback) {
      // Use current class loader - should always be bootstrap CL
      return Class.forName(className, true, FactoryFinder.class.getClassLoader());
    }

   



  更多可以参考理解:  jdbc的SPI 加载方式.  ![img](file:///C:\Users\zhulin\AppData\Roaming\Tencent\QQTempSys\%W@GJ$ACOF(TYDYECOKVDYB.png)https://blog.csdn.net/syh121/article/details/120274044

  ClassLoader cl = Thread.currentThread().getContextClassLoader();
  return ServiceLoader.load(service, cl);

\9. 双亲委派模式是默认的模式，但并非必须. 还有以下几个例 子，它实际上是破坏了双亲委派模式的. 
  a. Tomcat的WebappClassLoader 就会先加载自己的Class，找不到再委托parent
  b. OSGi的ClassLoader形成网状结构，根据需要自由加载Class

\10. 请完成一个热替换的例子，并解释什么是热替换?