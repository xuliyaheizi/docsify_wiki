# 分布式锁

## 一、概念

`分布式锁`：控制分布式系统有序的对共享资源进行操作，通过互斥来保持一致性。

### 分布式锁诞生的原因

在单机中，可以使用**锁机制**对一个共享变量进行多线程同步访问。

在集群中，一个应用需要部署到多台服务器上做负载均衡，如一个共享变量A存储在三台服务器上，不对变量A进行任何控制的话，变量A同时都会在各自的服务器上分配一块内存，此时若仍使用JAVA提供的原生锁机制的话，因原生锁机制只对属于自己JVM里面的线程能有效加锁，对于其他JVM的线程是无效的，这就导致原生锁机制在集群部署环境失效了。

要保证一个方法或属性在高并发情况下的同一时间只能被一个线程执行，需实现整个集群系统、不同机器上加的锁是同一把锁。因此分布式锁的思路：在整个系统中提供一个全局、唯一的获取锁的`东西`，然后每个机器在需要加锁的时候，都去问这个`东西`获取一把锁，这样整体系统中，不同机器拿到的锁都是同一把锁。`东西`可以是数据库、Redis缓存和Zookeeper分布式文件系统。

为了解决分布式集群系统中可保证一个方法或属性在高并发的情况下一次只能被一个线程执行就需要一种跨机器的互斥机制来控制共享资源的访问。

### 具备的条件

- 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行。
- 高可用的获取锁与释放锁。
- 高性能的获取锁与释放锁。
- 具备可重入特性。
- 具备锁失效机制、防止死锁。
- 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。

## 二、基于数据库实现分布式锁

`核心思想：`在数据库中创建一个表，表中包含**方法名**等字段，并在方法名字段上创建**唯一索引**，想要执行某一个方法，就使用该方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据删除锁。(插入成功获取锁、执行完成后删除行数据并释放锁)

```sql
DROP TABLE IF EXISTS `method_lock`;
CREATE TABLE `method_lock` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `method_name` varchar(64) NOT NULL COMMENT '锁定的方法名',
  `desc` varchar(255) NOT NULL COMMENT '备注信息',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uidx_method_name` (`method_name`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';
```

执行某个方法时，就使用该方法名向表中插入数据，由于对`method_name`做了`唯一性约束`，如果有多个请求同时提交到数据库的时候，数据库会保证只有一个操作可以成功，则认为操作成功的线程获得了该方法的锁，可以执行方法体内容。

```sql
INSERT INTO method_lock (method_name, desc) VALUES ('methodName', '测试的methodName');
```

成功插入则获取锁，执行完成后删除行数据并释放锁。

```sql
delete from method_lock where method_name ='methodName';
```

### 问题解决与优化

- 由于是基于数据库实现的，数据库的可用性和性能将直接影响分布式锁的可用性和性能，因此数据库需要双击部署、数据同步、主备切换。
- 不具备可重入的特性，因为同一个线程在释放锁之前，数据库中的行数据会一直存在，无法再次成功插入数据，因此需要在数据库中新增一列，用于记录当前获取到锁的机器和线程信息，在再次获取锁的时候，先查询表中机器和线程信息与当前的机器和线程是否相同，若相同则直接获取锁。
- 没有锁失效机制，可能出现成功插入数据后，服务器宕机了，而插入的数据没有被删除，当服务恢复后一直获取不到锁，所以需要在表中新增一列，用于记录失效的时间，并且需要定时任务清除这些失效的数据。
- 不具备阻塞锁特性，获取不到锁直接返回失败，需要优化获取逻辑，循环多次去获取。
- 在实施的过程中会遇到各种不同的问题，为了解决这些问题，实现方式将会越来越复杂。依赖数据库需要一定的资源开销，性能问题需要考虑。

## 三、基于Zookeeper实现分布式锁

### 核心原理

Zookeeper分布式锁主要是基于Zookeeper的**临时顺序节点**来实现的，当客户端来加锁的时候，会先在加锁的节点下建立一个子节点，此时该子节点会有一个序号，类似`lock-000001`，创建成功之后会返回给客户端所创建的节点，然后客户端去获取这个加锁节点下的所有客户端创建的子节点，且包括自己所创建的节点。拿到所有节点之后，给这些节点进行排序，然后判断自己创建的节点是否是第一位，若是则代表当前客户端加锁成功，反之则加锁失败。

加锁失败的节点不会不停的循环去尝试加锁（考虑性能问题），而是在自己创建节点的前一个节点上加一个监听器，然后进行等待（加锁失败的线程会进入等待队列）。当前面一个节点释放了锁，就会通知等待的客户端，然后客户端进行加锁。

**监听器的作用**

对于多个客户端来进行加锁，加锁失败的都会对前一个节点添加一个监听器（相当于都进入等待队列）。第一个加锁的客户端释放了锁后，会通过监听器通知第二个客户端进行加锁，第二个客户端执行完后释放锁，会通知第三个客户端加锁，以此类推。每次释放锁都会通知下一个节点，这样每个加锁的线程都会加锁成功。监听器的作用就是唤醒加锁失败阻塞等待的客户端。

### 临时顺序节点的作用

临时节点：指节点创建之后，当创建节点的客户端与Zookeeper服务端的会话失效（断开连接），那么临时节点就会被删除。

持久节点：指是节点创建后，即使创建节点的客户端和 Zookeeper 服务端的会话失效(例如断开连接)，节点也不会被删除，只有客户端主动发起删除节点的请求，节点才会被删除。

有序节点：指节点创建后会有一个序号，且这个序号是自增的。有序节点既可以是临时有序节点，也可以是持久有序节点。

临时节点相比持久节点，最主要的是对会话失效的情况处理不一样。若使用持久节点，当客户端发生异常时，未及时主动释放锁，就会使锁无法释放而导致死锁的情况。临时节点由于在客户端与服务器的会话失效时会自动删除节点的特点，可以在发生异常后释放锁，解决产生死锁的问题。redis和zk防止死锁的实现是不同的，redis是通过设置过期时间（无法准确掌握过期时间的设置，需通过实际需求调整）来防止死锁，而zk是通过临时节点来防止死锁。

顺序节点为防止羊群效应。若没有使用顺序节点，并假设多个客户端去进行加锁，加锁失败后都会对加锁的节点添加一个监听器，但是在锁释放后，所有的加锁客户端都会被唤醒进行加锁，此时会增加很多加锁的请求，造成服务端的压力。

## 四、基于Redis实现分布式锁

